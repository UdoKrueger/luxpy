<!DOCTYPE html>
<html class="writer-html4" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>luxpy.toolboxes.spdbuild.spdbuilder &mdash; LuxPy 1.9.8 documentation</title><link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../../" src="../../../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../../../_static/language_data.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> LuxPy
          </a>
              <div class="version">
                1.9.8
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../license.html">License: GPLv3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../required_packages.html">Imported (required) packages</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../luxpy_structure.html">Luxpy package structure</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">LuxPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>luxpy.toolboxes.spdbuild.spdbuilder</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for luxpy.toolboxes.spdbuild.spdbuilder</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Module for building and optimizing SPDs</span>
<span class="sd">=======================================</span>

<span class="sd">Functions</span>
<span class="sd">---------</span>

<span class="sd"> :gaussian_spd(): Generate Gaussian spectrum.</span>

<span class="sd"> :butterworth_spd(): Generate Butterworth based spectrum.</span>
<span class="sd"> </span>
<span class="sd"> :lorentzian2_spd(): Generate 2nd order Lorentzian based spectrum.</span>
<span class="sd"> </span>
<span class="sd"> :roundedtriangle_spd(): Generate a rounded triangle based spectrum.</span>

<span class="sd"> :mono_led_spd(): Generate monochromatic LED spectrum based on a Gaussian </span>
<span class="sd">                  or butterworth profile or according to Ohno (Opt. Eng. 2005).</span>

<span class="sd"> :spd_builder(): Build spectrum based on Gaussians, monochromatic </span>
<span class="sd">                 and/or phophor LED spectra.</span>

<span class="sd"> :color3mixer(): Calculate fluxes required to obtain a target chromaticity </span>
<span class="sd">                 when (additively) mixing 3 light sources.</span>

<span class="sd"> :colormixer(): Calculate fluxes required to obtain a target chromaticity </span>
<span class="sd">                when (additively) mixing N light sources.</span>
<span class="sd">                </span>
<span class="sd"> :colormixer_pinv(): Additive color mixer of N primaries using using Moore-Penrose pseudo-inverse matrix.</span>

<span class="sd"> :spd_builder(): Build spectrum based on Gaussians, monochromatic </span>
<span class="sd">                 and/or phophor LED-type spectra.</span>
<span class="sd">                   </span>
<span class="sd"> :get_w_summed_spd(): Calculate weighted sum of spds.</span>
<span class="sd"> </span>
<span class="sd"> :fitnessfcn(): Fitness function that calculates closeness of solution x to </span>
<span class="sd">                target values for specified objective functions.</span>
<span class="sd">         </span>
<span class="sd"> :spd_constructor_2(): Construct spd from spectral model parameters </span>
<span class="sd">                       using pairs of intermediate sources.</span>
<span class="sd">                </span>
<span class="sd"> :spd_constructor_3(): Construct spd from spectral model parameters </span>
<span class="sd">                       using trio&#39;s of intermediate sources.</span>
<span class="sd">     </span>
<span class="sd"> :spd_optimizer_2_3(): Optimizes the weights (fluxes) of a set of component </span>
<span class="sd">                       spectra by combining pairs (2) or trio&#39;s (3) of </span>
<span class="sd">                       components to intermediate sources until only 3 remain.</span>
<span class="sd">                       Color3mixer can then be called to calculate required </span>
<span class="sd">                       fluxes to obtain target chromaticity and fluxes are </span>
<span class="sd">                       then back-calculated.                                   </span>
<span class="sd">                        </span>
<span class="sd"> :get_optim_pars_dict(): Setup dict with optimization parameters.</span>
<span class="sd">                        </span>
<span class="sd"> :initialize_spd_model_pars(): Initialize spd_model_pars (for spd_constructor)</span>
<span class="sd">                               based on type of component_data.</span>

<span class="sd"> :initialize_spd_optim_pars(): Initialize spd_optim_pars (x0, lb, ub for use</span>
<span class="sd">                               with math.minimizebnd) based on type </span>
<span class="sd">                               of component_data (or predefined values in spd_model_pars dict).</span>
<span class="sd">                </span>
<span class="sd"> :get_primary_fluxratios(): Get flux ratios of primaries.</span>
<span class="sd">     </span>
<span class="sd"> :spd_optimizer(): Generate a spectrum with specified white point and optimized</span>
<span class="sd">                   for certain objective functions from a set of component </span>
<span class="sd">                   spectra or component spectrum model parameters.</span>
<span class="sd">                </span>
<span class="sd">References</span>
<span class="sd">----------</span>
<span class="sd">    1. `Ohno Y (2005). </span>
<span class="sd">    Spectral design considerations for white LED color rendering. </span>
<span class="sd">    Opt. Eng. 44, 111302. </span>
<span class="sd">    &lt;https://ws680.nist.gov/publication/get_pdf.cfm?pub_id=841839&gt;`_</span>

<span class="sd">.. codeauthor:: Kevin A.G. Smet (ksmet1977 at gmail.com)</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">luxpy</span> <span class="kn">import</span> <span class="p">(</span><span class="n">math</span><span class="p">,</span> <span class="n">_WL3</span><span class="p">,</span> <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">getwlr</span><span class="p">,</span> <span class="n">SPD</span><span class="p">,</span> <span class="n">spd_to_power</span><span class="p">,</span>
                   <span class="n">spd_to_xyz</span><span class="p">,</span> <span class="n">xyz_to_Yxy</span><span class="p">,</span> <span class="n">colortf</span><span class="p">,</span> <span class="n">xyz_to_cct</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">luxpy.utils</span> <span class="kn">import</span> <span class="n">np</span><span class="p">,</span> <span class="n">plt</span><span class="p">,</span> <span class="n">_EPS</span><span class="p">,</span> <span class="n">np2d</span><span class="p">,</span> <span class="n">vec_to_dict</span>
<span class="kn">from</span> <span class="nn">luxpy</span> <span class="kn">import</span> <span class="n">cri</span> 

<span class="c1">#np.set_printoptions(formatter={&#39;float&#39;: lambda x: &quot;{0:0.2e}&quot;.format(x)})</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gaussian_spd&#39;</span><span class="p">,</span><span class="s1">&#39;butterworth_spd&#39;</span><span class="p">,</span><span class="s1">&#39;lorentzian2_spd&#39;</span><span class="p">,</span><span class="s1">&#39;roundedtriangle_spd&#39;</span><span class="p">,</span>
           <span class="s1">&#39;mono_led_spd&#39;</span><span class="p">,</span><span class="s1">&#39;phosphor_led_spd&#39;</span><span class="p">,</span><span class="s1">&#39;spd_builder&#39;</span><span class="p">,</span>
           <span class="s1">&#39;get_w_summed_spd&#39;</span><span class="p">,</span><span class="s1">&#39;fitnessfcn&#39;</span><span class="p">,</span><span class="s1">&#39;spd_constructor_2&#39;</span><span class="p">,</span>
           <span class="s1">&#39;color3mixer&#39;</span><span class="p">,</span><span class="s1">&#39;colormixer&#39;</span><span class="p">,</span><span class="s1">&#39;colormixer_pinv&#39;</span><span class="p">,</span>
           <span class="s1">&#39;spd_constructor_3&#39;</span><span class="p">,</span><span class="s1">&#39;spd_optimizer_2_3&#39;</span><span class="p">,</span><span class="s1">&#39;get_optim_pars_dict&#39;</span><span class="p">,</span>
           <span class="s1">&#39;initialize_spd_model_pars&#39;</span><span class="p">,</span><span class="s1">&#39;initialize_spd_optim_pars&#39;</span><span class="p">,</span>
           <span class="s1">&#39;get_primary_fluxratios&#39;</span><span class="p">,</span><span class="s1">&#39;spd_optimizer&#39;</span><span class="p">]</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="gaussian_spd"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.gaussian_spd">[docs]</a><span class="k">def</span> <span class="nf">gaussian_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="mi">530</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate Gaussian spectrum.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :peakw: </span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Peak wavelength</span>
<span class="sd">        :fwhm:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Full-Width-Half-Maximum of gaussian.</span>
<span class="sd">        :wl: </span>
<span class="sd">            | _WL3, optional </span>
<span class="sd">            | Wavelength range.</span>
<span class="sd">        :with_wl:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | True outputs a ndarray with first row wavelengths.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with spectra. </span>
<span class="sd">    Note:</span>
<span class="sd">        | Gaussian:</span>
<span class="sd">        |    g = exp(-0.5*((wl - peakwl)/sig)**2)</span>
<span class="sd">        | with sig = fwhm/(2*(2*np.log(2))**0.5) </span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">getwlr</span><span class="p">(</span><span class="n">wl</span><span class="p">))</span> <span class="c1"># create wavelength range</span>
    <span class="n">fwhm_to_sig</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span> <span class="c1"># conversion factor for FWHM to sigma of Gaussian</span>
    <span class="n">spd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="p">((</span><span class="n">wl</span><span class="o">.</span><span class="n">T</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">peakwl</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">fwhm</span><span class="p">)</span><span class="o">*</span><span class="n">fwhm_to_sig</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">with_wl</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl</span><span class="p">,</span> <span class="n">spd</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">spd</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="lorentzian2_spd"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.lorentzian2_spd">[docs]</a><span class="k">def</span> <span class="nf">lorentzian2_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="mi">530</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate 2nd order Lorentzian spectrum.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :peakw: </span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Peak wavelength</span>
<span class="sd">        :fwhm:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Full-Width-Half-Maximum of lorentzian.</span>
<span class="sd">        :wl: </span>
<span class="sd">            | _WL3, optional </span>
<span class="sd">            | Wavelength range.</span>
<span class="sd">        :with_wl:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | True outputs a ndarray with first row wavelengths.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with spectra. </span>
<span class="sd">            </span>
<span class="sd">    Note:</span>
<span class="sd">        | Lorentzian (2nd order):</span>
<span class="sd">        |    lz = (1 + ((n*(wl - peakwl)/fwhm)**2))**(-2)</span>
<span class="sd">        |       with n = 2*(2**0.5-1)**0.5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">getwlr</span><span class="p">(</span><span class="n">wl</span><span class="p">))</span> <span class="c1"># create wavelength range</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mf">0.5</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
    <span class="n">spd</span> <span class="o">=</span> <span class="p">((</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">n</span><span class="o">*</span><span class="p">(</span><span class="n">wl</span><span class="o">.</span><span class="n">T</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">peakwl</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">fwhm</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">with_wl</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl</span><span class="p">,</span> <span class="n">spd</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">spd</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<span class="k">def</span> <span class="nf">butterworth_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="mi">530</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">bw_order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate Butterworth based spectrum.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :peakw: </span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Peak wavelength</span>
<span class="sd">        :fwhm:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Full-Width-Half-Maximum of butterworth.</span>
<span class="sd">        :bw_order: </span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | Order of the butterworth function.</span>
<span class="sd">        :wl:</span>
<span class="sd">            | _WL3, optional </span>
<span class="sd">            | Wavelength range.</span>
<span class="sd">        :with_wl:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | True outputs a ndarray with first row wavelengths.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with spectra.    </span>
<span class="sd">            </span>
<span class="sd">    Note:</span>
<span class="sd">        | Butterworth :</span>
<span class="sd">        |    bw = 1 / (1 + ((2*(wl - peakwl)/fwhm)**2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">getwlr</span><span class="p">(</span><span class="n">wl</span><span class="p">))</span> <span class="c1"># create wavelength range</span>
    <span class="n">spd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">wl</span><span class="o">.</span><span class="n">T</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">peakwl</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">fwhm</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bw_order</span><span class="p">))))</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">with_wl</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl</span><span class="p">,</span> <span class="n">spd</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">spd</span>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="butterworth_spd"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.butterworth_spd">[docs]</a><span class="k">def</span> <span class="nf">butterworth_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="mi">530</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">bw_order</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate Butterworth based spectrum.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :peakw: </span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Peak wavelength</span>
<span class="sd">        :fwhm:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Full-Width-Half-Maximum of butterworth.</span>
<span class="sd">        :bw_order: </span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | Order of the butterworth function.</span>
<span class="sd">        :wl:</span>
<span class="sd">            | _WL3, optional </span>
<span class="sd">            | Wavelength range.</span>
<span class="sd">        :with_wl:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | True outputs a ndarray with first row wavelengths.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with spectra.    </span>
<span class="sd">            </span>
<span class="sd">    Note:</span>
<span class="sd">        | Butterworth :</span>
<span class="sd">        |    bw = 1 / (1 + ((2*(wl - peakwl)/fwhm)**2))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">getwlr</span><span class="p">(</span><span class="n">wl</span><span class="p">))</span> <span class="c1"># create wavelength range</span>
    <span class="n">spd</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">wl</span><span class="o">.</span><span class="n">T</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">peakwl</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">fwhm</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bw_order</span><span class="p">))))</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">with_wl</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl</span><span class="p">,</span> <span class="n">spd</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">spd</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="roundedtriangle_spd"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.roundedtriangle_spd">[docs]</a><span class="k">def</span> <span class="nf">roundedtriangle_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="mi">530</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">rounding</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                        <span class="n">min_v</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">max_v</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                        <span class="n">fw</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">rw</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate rounded triangle spectrum.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :peakw: </span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Peak wavelength</span>
<span class="sd">        :fwhm:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Full-Width-Half-Maximum of rounded triangle.</span>
<span class="sd">        :rounding:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Amount of rounding of triangle corners (top, bottom-left, bottom-right)</span>
<span class="sd">        :wl: </span>
<span class="sd">            | _WL3, optional </span>
<span class="sd">            | Wavelength range.</span>
<span class="sd">        :with_wl:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | True outputs a ndarray with first row wavelengths.</span>
<span class="sd">        :min_v, max_v:</span>
<span class="sd">            | 0.0, 1.0, optional</span>
<span class="sd">            | Minimum and maximum of spd.</span>
<span class="sd">        :fw:</span>
<span class="sd">            | 100, optional</span>
<span class="sd">            | front width of triangle.</span>
<span class="sd">            | Only used when fwhm is set to None.</span>
<span class="sd">        :rw:</span>
<span class="sd">            | 100, optional</span>
<span class="sd">            | rear width of triangle.</span>
<span class="sd">            | Only used when fwhm is set to None.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with spectra. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">peakwl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">peakwl</span><span class="p">))</span>
    <span class="n">rounding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">rounding</span><span class="p">))</span>
    <span class="n">max_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">max_v</span><span class="p">))</span>
    <span class="n">min_v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">min_v</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">fwhm</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">fw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">fw</span><span class="p">))</span>
        <span class="n">rw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">rw</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">fwhm</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">rounding</span><span class="o">/</span><span class="mi">4</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">fw</span> <span class="o">=</span> <span class="n">width</span>
        <span class="n">rw</span> <span class="o">=</span> <span class="n">width</span>

    <span class="n">wl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">getwlr</span><span class="p">(</span><span class="n">wl</span><span class="p">))</span>
    <span class="n">wlp</span> <span class="o">=</span> <span class="p">(</span><span class="n">wl</span><span class="o">-</span><span class="n">peakwl</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    
    <span class="c1"># expand for slicing later on:</span>
    <span class="n">fw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">fw</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">wlp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">rounding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">rounding</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">wlp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">wlp</span><span class="o">/</span><span class="n">rw</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">wlp</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">x</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">wlp</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">/</span><span class="n">fw</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> 
    
    <span class="c1"># setup various conditions:</span>
    <span class="n">c0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">rounding</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">c1</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">rounding</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">_c2</span><span class="p">,</span> <span class="n">cc</span> <span class="o">=</span> <span class="n">c0</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">c1</span><span class="p">),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">+</span><span class="n">rounding</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">_c2</span> <span class="o">&amp;</span> <span class="n">cc</span><span class="p">)</span>
    <span class="n">c3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">_c2</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">cc</span><span class="p">))</span>
    
    <span class="c1"># apply conditional transformations:</span>
    <span class="n">rounding</span><span class="p">[</span><span class="n">rounding</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-308</span> <span class="c1"># avoid division by zero</span>
    <span class="n">Rraw</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">rounding</span><span class="o">/</span><span class="mi">4</span> <span class="o">-</span> <span class="mi">1</span><span class="o">/</span><span class="n">rounding</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">Rraw</span><span class="p">[</span><span class="n">c1</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">c1</span><span class="p">])</span>
    <span class="n">Rraw</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="mf">2.0</span><span class="o">/</span><span class="n">rounding</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span><span class="o">*</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">c2</span><span class="p">])</span> <span class="o">-</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">rounding</span><span class="p">[</span><span class="n">c2</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Rraw</span><span class="p">[</span><span class="n">c3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
    
    <span class="n">spd</span> <span class="o">=</span> <span class="n">min_v</span> <span class="o">+</span> <span class="p">(</span><span class="n">max_v</span> <span class="o">-</span> <span class="n">min_v</span><span class="p">)</span><span class="o">*</span><span class="n">Rraw</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">rounding</span><span class="o">/</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">with_wl</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl</span><span class="p">,</span> <span class="n">spd</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">spd</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="mono_led_spd"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.mono_led_spd">[docs]</a><span class="k">def</span> <span class="nf">mono_led_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="mi">530</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">strength_shoulder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">bw_order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate monochromatic LED spectrum based on a Gaussian or or Lorentzian or butterworth</span>
<span class="sd">    profile or according to Ohno (Opt. Eng. 2005).</span>
<span class="sd">        </span>
<span class="sd">    Args:</span>
<span class="sd">        :peakw:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Peak wavelength</span>
<span class="sd">        :fwhm:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Full-Width-Half-Maximum of gaussian used to simulate led.</span>
<span class="sd">        :wl: </span>
<span class="sd">            | _WL3, optional </span>
<span class="sd">            |  Wavelength range.</span>
<span class="sd">        :with_wl:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | True outputs a ndarray with first row wavelengths.</span>
<span class="sd">        :strength_shoulder:</span>
<span class="sd">            | 2, optional</span>
<span class="sd">            | Determines the strength of the spectrum shoulders of the mono led.</span>
<span class="sd">            | A value of 0 reduces to a pure Gaussian model (if bw_order &gt;= -1).</span>
<span class="sd">        :bw_order:</span>
<span class="sd">            | -1, optional</span>
<span class="sd">            | Order of Butterworth function.</span>
<span class="sd">            | If -1 or 0: spd profile is Ohno&#39;s gaussian based</span>
<span class="sd">            |          (to obtain pure Gaussian: set strength_shoulder = 0).</span>
<span class="sd">            | If -2: spd profile is Lorentzian,</span>
<span class="sd">            | else (&gt;0): Butterworth.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | ndarray with spectra.   </span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        | Gaussian:</span>
<span class="sd">        |    g = exp(-0.5*((wl - peakwl)/sig)**2)</span>
<span class="sd">        | with sig = fwhm/(2*(2*np.log(2))**0.5) </span>
<span class="sd">        |</span>
<span class="sd">        | Lorentzian (2nd order):</span>
<span class="sd">        |    lz = (1 + ((n*(wl - peakwl)/fwhm)**2))**(-2)</span>
<span class="sd">        |       with n = 2*(2**0.5-1)**0.5</span>
<span class="sd">        | </span>
<span class="sd">        | Butterworth :</span>
<span class="sd">        |    bw = 1 / (1 + ((2*(wl - peakwl)/fwhm)**2))</span>
<span class="sd">        | </span>
<span class="sd">        | Ohno&#39;s model:</span>
<span class="sd">        |    ohno = (g + strength_shoulder*g**5)/(1+strength_shoulder)</span>
<span class="sd">        |     </span>
<span class="sd">        |    mono_led_spd = ohno*((bw_order &gt;= -1) &amp; (bw_order &lt;= 0)).T + bw*(bw_order &gt; 0).T + lz*((bw_order &gt;=-2) &amp; (bw_order &lt; -1)).T</span>
<span class="sd">    </span>
<span class="sd">    Reference:</span>
<span class="sd">        1. `Ohno Y (2005). </span>
<span class="sd">        Spectral design considerations for white LED color rendering. </span>
<span class="sd">        Opt. Eng. 44, 111302. </span>
<span class="sd">        &lt;https://ws680.nist.gov/publication/get_pdf.cfm?pub_id=841839&gt;`_</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bw_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bw_order</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bw_order</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">lorentzian2_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="n">peakwl</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhm</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">gaussian_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="n">peakwl</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhm</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">ohno</span> <span class="o">=</span> <span class="p">(</span><span class="n">g</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">strength_shoulder</span><span class="p">)</span><span class="o">*</span><span class="n">g</span><span class="o">**</span><span class="mi">5</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">strength_shoulder</span><span class="p">))</span>
        <span class="n">bw_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bw_order</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bw_order</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">spd</span> <span class="o">=</span> <span class="n">ohno</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bw</span> <span class="o">=</span> <span class="n">butterworth_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="n">peakwl</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhm</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">bw_order</span> <span class="o">=</span> <span class="n">bw_order</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">lz</span> <span class="o">=</span> <span class="n">lorentzian2_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="n">peakwl</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhm</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">spd</span> <span class="o">=</span> <span class="n">ohno</span><span class="o">*</span><span class="p">((</span><span class="n">bw_order</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bw_order</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">bw</span><span class="o">*</span><span class="p">(</span><span class="n">bw_order</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">lz</span><span class="o">*</span><span class="p">((</span><span class="n">bw_order</span> <span class="o">&gt;=-</span><span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">bw_order</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="k">if</span> <span class="n">with_wl</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">getwlr</span><span class="p">(</span><span class="n">wl</span><span class="p">),</span> <span class="n">spd</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">spd</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="phosphor_led_spd"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.phosphor_led_spd">[docs]</a><span class="k">def</span> <span class="nf">phosphor_led_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="mi">450</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">,</span> <span class="n">bw_order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">strength_shoulder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>\
                    <span class="n">strength_ph</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">peakwl_ph1</span> <span class="o">=</span> <span class="mi">530</span><span class="p">,</span> <span class="n">fwhm_ph1</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span> <span class="n">strength_ph1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>\
                    <span class="n">peakwl_ph2</span> <span class="o">=</span> <span class="mi">560</span><span class="p">,</span> <span class="n">fwhm_ph2</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span> <span class="n">strength_ph2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                    <span class="n">use_piecewise_fcn</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>\
                    <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;spd&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate phosphor LED spectrum with up to 2 phosphors based on Smet (Opt. Expr. 2011).</span>
<span class="sd">    </span>
<span class="sd">    | Model:</span>
<span class="sd">    |    1) If strength_ph2 is not None:</span>
<span class="sd">    |          phosphor_spd = (strength_ph1*mono_led_spd(peakwl_ph1, ..., strength_shoulder = 1) </span>
<span class="sd">    |                       + strength_ph2)*mono_led_spd(peakwl_ph2, ..., strength_shoulder = 1)) </span>
<span class="sd">    |                        / (strength_ph1 + strength_ph2)</span>
<span class="sd">    |      else:</span>
<span class="sd">    |          phosphor_spd = (strength_ph1*mono_led_spd(peakwl_ph1, ..., strength_shoulder = 1) </span>
<span class="sd">    |                       + (1-strength_ph1)*mono_led_spd(peakwl_ph2, ..., strength_shoulder = 1)) </span>
<span class="sd">    |</span>
<span class="sd">    |    2) S = (mono_led_spd() + strength_ph*(phosphor_spd/phosphor_spd.max()))/(1 + strength_ph)</span>
<span class="sd">    |    </span>
<span class="sd">    |    3) piecewise_fcn = S for wl &lt; peakwl and 1 for wl &gt;= peakwl</span>
<span class="sd">    |    </span>
<span class="sd">    |    4) phosphor_led_spd = S*piecewise_fcn </span>
<span class="sd">            </span>
<span class="sd">    Args:</span>
<span class="sd">        :peakw:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Peak wavelengths of the monochromatic led.</span>
<span class="sd">        :fwhm:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Full-Width-Half-Maximum of mono_led spectrum.</span>
<span class="sd">        :wl: | _WL3, optional </span>
<span class="sd">            | Wavelength range.</span>
<span class="sd">        :bw_order:</span>
<span class="sd">            | -1, optional</span>
<span class="sd">            | Order of Butterworth function.</span>
<span class="sd">            | If -1 or 0: spd profile is Ohno&#39;s gaussian based</span>
<span class="sd">            |          (to obtain pure Gaussian: set strength_shoulder = 0).</span>
<span class="sd">            | If -2: spd profile is Lorentzian,</span>
<span class="sd">            | else (&gt;0): Butterworth.</span>
<span class="sd">            | Note that this only applies to the monochromatic led  spds and not </span>
<span class="sd">            | the phosphors spds (these are always gaussian based).</span>
<span class="sd">        :with_wl:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | True outputs a ndarray with first row wavelengths.</span>
<span class="sd">        :strength_shoulder: </span>
<span class="sd">            | 2, optiona l</span>
<span class="sd">            | Determines the strength of the spectrum shoulders of the mono led.</span>
<span class="sd">        :strength_ph:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Total contribution of phosphors in mixture.</span>
<span class="sd">        :peakwl_ph1:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Peak wavelength of the first phosphor.</span>
<span class="sd">        :fwhm_ph1:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Full-Width-Half-Maximum of gaussian used to simulate first phosphor.</span>
<span class="sd">        :strength_ph1:</span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | Strength of first phosphor in phosphor mixture. </span>
<span class="sd">            | If :strength_ph2: is None: value should be in the [0,1] range.</span>
<span class="sd">        :peakwl_ph2:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Peak wavelength of the second phosphor.</span>
<span class="sd">        :fwhm_ph2: </span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Full-Width-Half-Maximum of gaussian used to simulate second phosphor.</span>
<span class="sd">        :strength_ph2:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Strength of second phosphor in phosphor mixture. </span>
<span class="sd">            | If None: strength is calculated as (1-:strength_ph1:)</span>
<span class="sd">            |     :target: np2d([100,1/3,1/3]), optional</span>
<span class="sd">            |  ndarray with Yxy chromaticity of target.</span>
<span class="sd">        :verbosity:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | If &gt; 0: plots spectrum components (mono_led, ph1, ph2, ...)</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;spd&#39;, optional</span>
<span class="sd">            | Specifies output.</span>
<span class="sd">        :use_piecewise_fcn:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | True: uses piece-wise function as in Smet et al. 2011. Can give </span>
<span class="sd">            | non_smooth spectra optimized from components to which it is applied. </span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | spd, component_spds</span>
<span class="sd">            | ndarrays with spectra (and component spds used to build the </span>
<span class="sd">            | final spectra) </span>
<span class="sd">        </span>
<span class="sd">        </span>
<span class="sd">    References:</span>
<span class="sd">        1. `Ohno Y (2005). </span>
<span class="sd">        Spectral design considerations for white LED color rendering. </span>
<span class="sd">        Opt. Eng. 44, 111302. </span>
<span class="sd">        &lt;https://ws680.nist.gov/publication/get_pdf.cfm?pub_id=841839&gt;`_</span>

<span class="sd">        2. `Smet K, Ryckaert WR, Pointer MR, Deconinck G, and Hanselaer P (2011). </span>
<span class="sd">        Optimal colour quality of LED clusters based on memory colours. </span>
<span class="sd">        Opt. Express 19, 6903–6912.</span>
<span class="sd">        &lt;https://www.osapublishing.org/vjbo/fulltext.cfm?uri=oe-19-7-6903&amp;id=211315&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
        
    <span class="n">mono_led</span> <span class="o">=</span> <span class="n">mono_led_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="n">peakwl</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhm</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">bw_order</span> <span class="o">=</span> <span class="n">bw_order</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">strength_shoulder</span> <span class="o">=</span> <span class="n">strength_shoulder</span><span class="p">)</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">getwlr</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">strength_ph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">strength_ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">strength_ph</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">strength_ph</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span> <span class="c1"># Use phophor type led for obtaining target:</span>
            <span class="n">ph1</span> <span class="o">=</span> <span class="n">mono_led_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="n">peakwl_ph1</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhm_ph1</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">strength_shoulder</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">ph2</span> <span class="o">=</span> <span class="n">mono_led_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="n">peakwl_ph2</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhm_ph2</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">strength_shoulder</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">component_spds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dstack</span><span class="p">((</span><span class="n">mono_led</span><span class="p">,</span><span class="n">ph1</span><span class="p">,</span><span class="n">ph2</span><span class="p">))</span>
           
            <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;spd&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)):</span>
                <span class="n">strength_ph1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">strength_ph1</span><span class="p">)</span>
                <span class="n">strength_ph2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">strength_ph2</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">((</span><span class="n">ph1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">ph2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">strength_ph2</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                        <span class="n">phosphors</span> <span class="o">=</span> <span class="p">(</span><span class="n">strength_ph1</span><span class="o">*</span><span class="n">ph1</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">strength_ph2</span><span class="o">*</span><span class="n">ph2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">/</span><span class="p">(</span><span class="n">strength_ph1</span> <span class="o">+</span> <span class="n">strength_ph2</span> <span class="o">+</span> <span class="n">_EPS</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">_EPS</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">phosphors</span> <span class="o">=</span> <span class="p">(</span><span class="n">strength_ph1</span><span class="o">*</span><span class="n">ph1</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">strength_ph1</span><span class="p">)</span><span class="o">*</span><span class="n">ph2</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">_EPS</span>
                    <span class="n">strength_ph</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">strength_ph</span><span class="p">)</span>
                    <span class="n">phosphors</span> <span class="o">=</span> <span class="n">phosphors</span><span class="o">/</span><span class="n">phosphors</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
                    
                    <span class="n">spd</span> <span class="o">=</span> <span class="n">mono_led</span> <span class="o">+</span> <span class="p">(</span><span class="n">strength_ph</span><span class="o">*</span><span class="n">phosphors</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">phosphors</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="n">spd</span> <span class="o">=</span> <span class="n">mono_led</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                
        <span class="k">else</span><span class="p">:</span> <span class="c1"># Only monochromatic leds:</span>
            <span class="n">ph1</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ph2</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">phosphors</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">spd</span> <span class="o">=</span> <span class="n">mono_led</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">component_spds</span> <span class="o">=</span> <span class="n">mono_led</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">else</span><span class="p">:</span> <span class="c1"># Only monochromatic leds:</span>
        <span class="n">ph1</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ph2</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">phosphors</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">mono_led</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">component_spds</span> <span class="o">=</span> <span class="n">mono_led</span><span class="p">[:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>


    <span class="k">if</span> <span class="p">(</span><span class="n">use_piecewise_fcn</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">peakwl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">peakwl</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;component_spds&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)):</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="n">component_spds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">wl</span> <span class="o">&gt;=</span> <span class="n">peakwl</span><span class="p">[</span><span class="n">i</span><span class="p">]),:]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">component_spds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">component_spds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">fp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="c1"># multiplication with piecewise function f&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;spd&#39;</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)):</span>
            <span class="n">fp</span> <span class="o">=</span> <span class="n">mono_led</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">fp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">wl</span> <span class="o">&gt;=</span> <span class="n">peakwl</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">spd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">spd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">fp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="c1"># multiplication with piecewise function f&#39;</span>

    <span class="c1"># Normalize to max = 1:</span>
    <span class="n">spd</span> <span class="o">=</span> <span class="n">spd</span><span class="o">/</span><span class="n">spd</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">component_spds</span> <span class="o">=</span> <span class="n">component_spds</span><span class="o">/</span><span class="n">component_spds</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">mono_led_str</span> <span class="o">=</span> <span class="s1">&#39;Mono_led_1&#39;</span>
        <span class="n">ph1_str</span> <span class="o">=</span> <span class="s1">&#39;Phosphor_1&#39;</span>
        <span class="n">ph2_str</span> <span class="o">=</span> <span class="s1">&#39;Phosphor_2&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">ph1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span><span class="n">mono_led</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="s1">&#39;b--&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">mono_led_str</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span><span class="n">ph1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="s1">&#39;g:&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">ph1_str</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span><span class="n">ph2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="s1">&#39;y:&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="n">ph2_str</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">phosphors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span><span class="n">phosphors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Ph1,2 combined&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span><span class="n">spd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Output spd&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Wavelengths (nm)&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Normalized spectral intensity (max = 1)&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">with_wl</span> <span class="o">==</span> <span class="kc">True</span><span class="p">):</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl</span><span class="p">,</span> <span class="n">spd</span><span class="p">))</span>
        <span class="n">component_spds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl</span><span class="p">,</span> <span class="n">component_spds</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;spd&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spd</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;component_spds&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">component_spds</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;spd,component_spds&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spd</span><span class="p">,</span> <span class="n">component_spds</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="spd_builder"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.spd_builder">[docs]</a><span class="k">def</span> <span class="nf">spd_builder</span><span class="p">(</span><span class="n">flux</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">component_spds</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">peakwl</span> <span class="o">=</span> <span class="mi">450</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">bw_order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>\
                <span class="n">pair_strengths</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">strength_shoulder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>\
                <span class="n">strength_ph</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">peakwl_ph1</span> <span class="o">=</span> <span class="mi">530</span><span class="p">,</span> <span class="n">fwhm_ph1</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span> <span class="n">strength_ph1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>\
                <span class="n">peakwl_ph2</span> <span class="o">=</span> <span class="mi">560</span><span class="p">,</span> <span class="n">fwhm_ph2</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span> <span class="n">strength_ph2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                <span class="n">target</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">tar_type</span> <span class="o">=</span> <span class="s1">&#39;Yuv&#39;</span><span class="p">,</span> <span class="n">cspace_bwtf</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span>\
                <span class="n">use_piecewise_fcn</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;spd&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build spectrum based on Gaussian, monochromatic and/or phophor type spectra.</span>
<span class="sd">           </span>
<span class="sd">    Args:</span>
<span class="sd">        :flux: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Fluxes of each of the component spectra.</span>
<span class="sd">            | None outputs the individual component spectra.</span>
<span class="sd">        :component_spds:</span>
<span class="sd">            | None or ndarray, optional</span>
<span class="sd">            | If None: calculate component spds from input args.</span>
<span class="sd">        :peakw:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Peak wavelengths of the monochromatic led.</span>
<span class="sd">        :fwhm:</span>
<span class="sd">            | int or float or list or ndarray, optional (but must be same shape as peakw!)</span>
<span class="sd">            | Full-Width-Half-Maximum of gaussian.</span>
<span class="sd">        :wl:</span>
<span class="sd">            | _WL3, optional</span>
<span class="sd">            | Wavelength range.</span>
<span class="sd">        :bw_order:</span>
<span class="sd">            | -1, optional</span>
<span class="sd">            | Order of Butterworth function.</span>
<span class="sd">            | If -1 or 0: spd profile is Ohno&#39;s gaussian based</span>
<span class="sd">            |          (to obtain pure Gaussian: set strength_shoulder = 0).</span>
<span class="sd">            | If -2: spd profile is Lorentzian,</span>
<span class="sd">            | else (&gt;0): Butterworth.</span>
<span class="sd">            | Note that this only applies to the monochromatic led  spds and not </span>
<span class="sd">            | the phosphors spds (these are always gaussian based).</span>
<span class="sd">        :pair_strengths:</span>
<span class="sd">            | ndarray with pair_strengths of mono_led spds, optional</span>
<span class="sd">            | If None: will be randomly selected, possibly resulting in </span>
<span class="sd">            | unphysical (out-of-gamut) solution.</span>
<span class="sd">        :with_wl:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | True outputs a ndarray with first row wavelengths.</span>
<span class="sd">        :strength_shoulder: </span>
<span class="sd">            | 2, optiona l</span>
<span class="sd">            | Determines the strength of the spectrum shoulders of the mono led.</span>
<span class="sd">        :strength_ph:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | Total contribution of phosphors in mixture.</span>
<span class="sd">        :peakwl_ph1:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Peak wavelength of the first phosphor.</span>
<span class="sd">        :fwhm_ph1:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Full-Width-Half-Maximum of gaussian used to simulate first phosphor.</span>
<span class="sd">        :strength_ph1:</span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | Strength of first phosphor in phosphor mixture. </span>
<span class="sd">            | If :strength_ph2: is None: value should be in the [0,1] range.</span>
<span class="sd">        :peakwl_ph2:</span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Peak wavelength of the second phosphor.</span>
<span class="sd">        :fwhm_ph2: </span>
<span class="sd">            | int or float or list or ndarray, optional</span>
<span class="sd">            | Full-Width-Half-Maximum of gaussian used to simulate second phosphor.</span>
<span class="sd">        :strength_ph2:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Strength of second phosphor in phosphor mixture. </span>
<span class="sd">            | If None: strength is calculated as (1-:strength_ph1:)</span>
<span class="sd">            |     :target: np2d([100,1/3,1/3]), optional</span>
<span class="sd">            |  ndarray with Yxy chromaticity of target.</span>
<span class="sd">        :verbosity:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | If &gt; 0: plots spectrum components (mono_led, ph1, ph2, ...)</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;spd&#39;, optional</span>
<span class="sd">            | Specifies output.</span>
<span class="sd">        :use_piecewise_fcn:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | True: uses piece-wise function as in Smet et al. 2011. Can give </span>
<span class="sd">            | non_smooth spectra optimized from components to which it is</span>
<span class="sd">            | applied. </span>
<span class="sd">        :target: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | ndarray with Yxy chromaticity of target.</span>
<span class="sd">            | If None: don&#39;t override phosphor strengths, else calculate strength</span>
<span class="sd">            |           to obtain :target: using color3mixer().</span>
<span class="sd">            | If not None AND strength_ph is None or 0: components are </span>
<span class="sd">            | monochromatic and colormixer is used to optimize fluxes to </span>
<span class="sd">            | obtain target chromaticity (N can be &gt; 3 components)</span>
<span class="sd">        :tar_type:</span>
<span class="sd">            | &#39;Yxy&#39; or str, optional</span>
<span class="sd">            | Specifies the input type in :target: (e.g. &#39;Yxy&#39; or &#39;cct&#39;)</span>
<span class="sd">        :cieobs:</span>
<span class="sd">            | _CIEOBS, optional</span>
<span class="sd">            | CIE CMF set used to calculate chromaticity values.</span>
<span class="sd">        :cspace_bwtf:</span>
<span class="sd">            | {}, optional</span>
<span class="sd">            | Backward (..._to_xyz) transform parameters </span>
<span class="sd">            | (see colortf()) to go from :tar_type: to &#39;Yxy&#39;)</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with spectra.  </span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        1. Target-optimization is only for phophor_leds with three components </span>
<span class="sd">        (blue pump, ph1 and ph2) spanning a sufficiently large gamut. </span>
<span class="sd">        </span>
<span class="sd">    References:</span>
<span class="sd">        1. `Ohno Y (2005). </span>
<span class="sd">        Spectral design considerations for white LED color rendering. </span>
<span class="sd">        Opt. Eng. 44, 111302. </span>
<span class="sd">        &lt;https://ws680.nist.gov/publication/get_pdf.cfm?pub_id=841839&gt;`_</span>

<span class="sd">        2. `Smet K, Ryckaert WR, Pointer MR, Deconinck G, and Hanselaer P (2011). </span>
<span class="sd">        Optimal colour quality of LED clusters based on memory colours. </span>
<span class="sd">        Opt. Express 19, 6903–6912.</span>
<span class="sd">        &lt;https://www.osapublishing.org/vjbo/fulltext.cfm?uri=oe-19-7-6903&amp;id=211315&gt;`_</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">component_spds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spd</span><span class="p">,</span> <span class="n">component_spds</span> <span class="o">=</span> <span class="n">phosphor_led_spd</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="n">peakwl</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhm</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span> <span class="n">bw_order</span> <span class="o">=</span> <span class="n">bw_order</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">strength_shoulder</span> <span class="o">=</span> <span class="n">strength_shoulder</span><span class="p">,</span>\
                                           <span class="n">strength_ph</span> <span class="o">=</span> <span class="n">strength_ph</span><span class="p">,</span> <span class="n">peakwl_ph1</span> <span class="o">=</span> <span class="n">peakwl_ph1</span><span class="p">,</span> <span class="n">fwhm_ph1</span> <span class="o">=</span> <span class="n">fwhm_ph1</span><span class="p">,</span> <span class="n">strength_ph1</span> <span class="o">=</span> <span class="n">strength_ph1</span><span class="p">,</span>\
                                           <span class="n">peakwl_ph2</span> <span class="o">=</span> <span class="n">peakwl_ph2</span><span class="p">,</span> <span class="n">fwhm_ph2</span> <span class="o">=</span> <span class="n">fwhm_ph2</span><span class="p">,</span> <span class="n">strength_ph2</span> <span class="o">=</span> <span class="n">strength_ph2</span><span class="p">,</span>\
                                           <span class="n">use_piecewise_fcn</span> <span class="o">=</span> <span class="n">use_piecewise_fcn</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;spd,component_spds&#39;</span><span class="p">)</span>
        
        <span class="n">wl</span> <span class="o">=</span> <span class="n">getwlr</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">wl</span> <span class="o">=</span> <span class="n">component_spds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">component_spds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">component_spds</span> <span class="o">=</span> <span class="n">component_spds</span><span class="p">[</span><span class="mi">1</span><span class="p">:][:,:,</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="c1"># use component_spectra to build spds with target chromaticity</span>
        <span class="c1"># (ignores strength_ph values).</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">component_spds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># rgb components are grouped </span>

        <span class="k">if</span> <span class="n">component_spds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;spd_builder(): Not enough component spectra for color3mixer(). Min. is 3&#39;</span><span class="p">)</span>
        
        <span class="n">temp</span> <span class="o">=</span> <span class="n">component_spds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">.</span><span class="n">transpose</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">temp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">temp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">temp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">component_spds_2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl</span><span class="p">,</span><span class="n">temp</span><span class="p">))</span>
                
        <span class="c1"># Calculate xyz of components:</span>
        <span class="n">xyzi</span> <span class="o">=</span> <span class="n">spd_to_xyz</span><span class="p">(</span><span class="n">component_spds_2d</span><span class="p">,</span> <span class="n">relative</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">)</span>

        <span class="c1"># Calculate Yxy:</span>
        <span class="n">Yxyt</span> <span class="o">=</span> <span class="n">colortf</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">tf</span> <span class="o">=</span> <span class="n">tar_type</span><span class="o">+</span><span class="s1">&#39;&gt;Yxy&#39;</span><span class="p">,</span> <span class="n">bwtf</span> <span class="o">=</span> <span class="n">cspace_bwtf</span><span class="p">)</span>
        <span class="n">Yxyi</span> <span class="o">=</span> <span class="n">xyz_to_Yxy</span><span class="p">(</span><span class="n">xyzi</span><span class="p">)</span> <span class="c1">#input for color3mixer is Yxy</span>
        
<span class="c1">#        if verbosity &gt; 0:</span>
<span class="c1">#            plt.figure()</span>
<span class="c1">#            plt.plot(Yxyt[0,1],Yxyt[0,2],&#39;k+&#39;)</span>
<span class="c1">#            plt.plot(Yxyi[:N,1],Yxyi[:N,2],&#39;bd&#39;)</span>
<span class="c1">#            plt.plot(Yxyi[N:2*N,1],Yxyi[N:2*N,2],&#39;gs&#39;)</span>
<span class="c1">#            plt.plot(Yxyi[2*N:3*N,1],Yxyi[2*N:3*N,2],&#39;rp&#39;)</span>
<span class="c1">#            plt.plot(Yxyi[3*N:4*N,1],Yxyi[3*N:4*N,2],&#39;mo&#39;)</span>
<span class="c1">#            plotSL(cspace =&#39;Yxy&#39;)</span>

        <span class="c1"># Calculate fluxes for obtaining target chromaticity:</span>
        <span class="k">if</span> <span class="n">component_spds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># mono_led spectra can have more than 3 componenents</span>
            <span class="k">if</span> <span class="n">pair_strengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">())</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">size</span><span class="o">!=</span><span class="mi">3</span><span class="p">):</span> <span class="c1">#if outside of gamut for 3 components than it will always be outside of gamut</span>
                    <span class="n">M</span> <span class="o">=</span> <span class="n">colormixer</span><span class="p">(</span><span class="n">Yxyt</span> <span class="o">=</span> <span class="n">Yxyt</span><span class="p">,</span> <span class="n">Yxyi</span> <span class="o">=</span> <span class="n">Yxyi</span><span class="p">,</span> <span class="n">pair_strengths</span> <span class="o">=</span> <span class="n">pair_strengths</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">M</span> <span class="o">=</span> <span class="n">colormixer</span><span class="p">(</span><span class="n">Yxyt</span> <span class="o">=</span> <span class="n">Yxyt</span><span class="p">,</span> <span class="n">Yxyi</span> <span class="o">=</span> <span class="n">Yxyi</span><span class="p">,</span> <span class="n">pair_strengths</span> <span class="o">=</span> <span class="n">pair_strengths</span><span class="p">)</span>
            <span class="n">M</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">M</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">color3mixer</span><span class="p">(</span><span class="n">Yxyt</span><span class="p">,</span><span class="n">Yxyi</span><span class="p">[:</span><span class="n">N</span><span class="p">,:],</span><span class="n">Yxyi</span><span class="p">[</span><span class="n">N</span><span class="p">:</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,:],</span><span class="n">Yxyi</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">:</span><span class="mi">3</span><span class="o">*</span><span class="n">N</span><span class="p">,:])</span> <span class="c1"># phosphor type spectra (3 components)</span>

        <span class="c1"># Calculate spectrum:</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">dot23</span><span class="p">(</span><span class="n">M</span><span class="p">,</span><span class="n">component_spds</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">([</span><span class="n">spd</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>
        <span class="n">spdmax</span> <span class="o">=</span> <span class="n">spd</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">spdmax</span><span class="p">[</span><span class="n">spdmax</span><span class="o">==</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="c1"># avoid division by zero</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">spd</span><span class="o">/</span><span class="n">spdmax</span>
        <span class="n">spd</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">spd</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        
        
        <span class="c1"># Mark out_of_gamut solution with NaN&#39;s:</span>
        <span class="n">is_out_of_gamut</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(((</span><span class="n">M</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">spd</span><span class="p">[</span><span class="n">is_out_of_gamut</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="n">M</span><span class="p">[</span><span class="n">is_out_of_gamut</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">is_out_of_gamut</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;spd_builder(): At least one solution is out of gamut. Check for NaN&#39;s in spd.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">component_spds_plot</span> <span class="o">=</span> <span class="n">component_spds</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">component_spds_plot</span> <span class="o">=</span> <span class="n">component_spds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">spd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">component_spds_plot</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span><span class="n">component_spds_plot</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;b--&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Component 1&#39;</span><span class="p">)</span>
                
                <span class="c1"># if (strength_ph is not None) &amp; (strength_ph is not 0): # raises SyntaxWarning: &quot;is&quot; with a literal. Did you mean &quot;==&quot;?</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">strength_ph</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strength_ph</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">strength_ph</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span><span class="n">component_spds_plot</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;g:&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Component 2&#39;</span><span class="p">)</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span><span class="n">component_spds_plot</span><span class="p">[</span><span class="n">i</span><span class="p">,:,</span><span class="mi">2</span><span class="p">],</span><span class="s1">&#39;y:&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Component 3&#39;</span><span class="p">)</span>
            
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">wl</span><span class="p">,</span><span class="n">spd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s1">&#39;Output spd&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Wavelengths (nm)&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Normalized spectral intensity (max = 1)&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">flux</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">flux</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">flux</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">spd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">spd_is_not_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">spd</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">==</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1">#keep only not nan spds</span>
            <span class="n">spd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">flux</span><span class="p">[:,</span><span class="n">spd_is_not_nan</span><span class="p">],</span><span class="n">spd</span><span class="p">[</span><span class="n">spd_is_not_nan</span><span class="p">,:])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">spd</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">spd</span><span class="o">/</span><span class="n">spd</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
    
    <span class="k">if</span> <span class="n">with_wl</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">spd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl</span><span class="p">,</span> <span class="n">spd</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;spd&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spd</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;M&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">M</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;spd,M&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spd</span><span class="p">,</span> <span class="n">M</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;spd,M,component_spds&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spd</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">component_spds</span>
<span class="c1">#    elif out == &#39;component_spds&#39;:</span>
<span class="c1">#        return component_spds</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;spd,component_spds&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spd</span><span class="p">,</span> <span class="n">component_spds</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>




   
<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="color3mixer"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.color3mixer">[docs]</a><span class="k">def</span> <span class="nf">color3mixer</span><span class="p">(</span><span class="n">Yxyt</span><span class="p">,</span><span class="n">Yxy1</span><span class="p">,</span><span class="n">Yxy2</span><span class="p">,</span><span class="n">Yxy3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate fluxes required to obtain a target chromaticity </span>
<span class="sd">    when (additively) mixing 3 light sources.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :Yxyt: </span>
<span class="sd">            | ndarray with target Yxy chromaticities.</span>
<span class="sd">        :Yxy1: </span>
<span class="sd">            | ndarray with Yxy chromaticities of light sources 1.</span>
<span class="sd">        :Yxy2:</span>
<span class="sd">            | ndarray with Yxy chromaticities of light sources 2.</span>
<span class="sd">        :Yxy3:</span>
<span class="sd">            | ndarray with Yxy chromaticities of light sources 3.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :M: </span>
<span class="sd">            | ndarray with fluxes.</span>
<span class="sd">        </span>
<span class="sd">    Note:</span>
<span class="sd">        Yxyt, Yxy1, ... can contain multiple rows, referring to single mixture.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Y1</span> <span class="o">=</span> <span class="n">Yxy1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">Yxy1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y1</span> <span class="o">=</span> <span class="n">Yxy1</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Y2</span> <span class="o">=</span> <span class="n">Yxy2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">Yxy2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y2</span> <span class="o">=</span> <span class="n">Yxy2</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Y3</span> <span class="o">=</span> <span class="n">Yxy3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">x3</span> <span class="o">=</span> <span class="n">Yxy3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">y3</span> <span class="o">=</span> <span class="n">Yxy3</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">Yt</span> <span class="o">=</span> <span class="n">Yxyt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">xt</span> <span class="o">=</span> <span class="n">Yxyt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">yt</span> <span class="o">=</span> <span class="n">Yxyt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">y1</span><span class="o">*</span><span class="p">((</span><span class="n">xt</span><span class="o">-</span><span class="n">x3</span><span class="p">)</span><span class="o">*</span><span class="n">y2</span><span class="o">-</span><span class="p">(</span><span class="n">yt</span><span class="o">-</span><span class="n">y3</span><span class="p">)</span><span class="o">*</span><span class="n">x2</span><span class="o">+</span><span class="n">x3</span><span class="o">*</span><span class="n">yt</span><span class="o">-</span><span class="n">xt</span><span class="o">*</span><span class="n">y3</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">yt</span><span class="o">*</span><span class="p">((</span><span class="n">x3</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span><span class="o">*</span><span class="n">y1</span><span class="o">+</span><span class="p">(</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">*</span><span class="n">y3</span><span class="o">+</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x3</span><span class="p">)</span><span class="o">*</span><span class="n">y2</span><span class="p">))</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="o">-</span><span class="n">y2</span><span class="o">*</span><span class="p">((</span><span class="n">xt</span><span class="o">-</span><span class="n">x3</span><span class="p">)</span><span class="o">*</span><span class="n">y1</span><span class="o">-</span><span class="p">(</span><span class="n">yt</span><span class="o">-</span><span class="n">y3</span><span class="p">)</span><span class="o">*</span><span class="n">x1</span><span class="o">+</span><span class="n">x3</span><span class="o">*</span><span class="n">yt</span><span class="o">-</span><span class="n">xt</span><span class="o">*</span><span class="n">y3</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">yt</span><span class="o">*</span><span class="p">((</span><span class="n">x3</span><span class="o">-</span><span class="n">x2</span><span class="p">)</span><span class="o">*</span><span class="n">y1</span><span class="o">+</span><span class="p">(</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">*</span><span class="n">y3</span><span class="o">+</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x3</span><span class="p">)</span><span class="o">*</span><span class="n">y2</span><span class="p">))</span>
    <span class="n">m3</span> <span class="o">=</span> <span class="n">y3</span><span class="o">*</span><span class="p">((</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">*</span><span class="n">yt</span><span class="o">-</span><span class="p">(</span><span class="n">y2</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span><span class="o">*</span><span class="n">xt</span><span class="o">+</span><span class="n">x1</span><span class="o">*</span><span class="n">y2</span><span class="o">-</span><span class="n">x2</span><span class="o">*</span><span class="n">y1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">yt</span><span class="o">*</span><span class="p">((</span><span class="n">x2</span><span class="o">-</span><span class="n">x1</span><span class="p">)</span><span class="o">*</span><span class="n">y3</span><span class="o">-</span><span class="p">(</span><span class="n">y2</span><span class="o">-</span><span class="n">y1</span><span class="p">)</span><span class="o">*</span><span class="n">x3</span><span class="o">+</span><span class="n">x1</span><span class="o">*</span><span class="n">y2</span><span class="o">-</span><span class="n">x2</span><span class="o">*</span><span class="n">y1</span><span class="p">))</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">Yt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">m1</span><span class="o">/</span><span class="n">Y1</span><span class="p">,</span><span class="n">m2</span><span class="o">/</span><span class="n">Y2</span><span class="p">,</span><span class="n">m3</span><span class="o">/</span><span class="n">Y3</span><span class="p">))</span>
<span class="c1">#    a = (Yxyt[...,2]*((Yxy3[...,1]-Yxy2[...,1])*Yxy1[...,2]+(Yxy2[...,1]-Yxy1[...,1])*Yxy3[...,2]+(Yxy1[...,1]-Yxy3[...,1])*Yxy2[...,2]))</span>
<span class="c1">#    b = (Yxyt[...,2]*((Yxy2[...,1]-Yxy1[...,1])*Yxy3[...,2]-(Yxy2[...,2]-Yxy1[...,2])*Yxy3[...,1]+Yxy1[...,1]*Yxy2[...,2]-Yxy2[...,1]*Yxy1[...,2]))</span>
<span class="c1">#    m1 = Yxy1[...,2]*((Yxyt[...,1]-Yxy3[...,1])*Yxy2[...,2]-(Yxyt[...,2]-Yxy3[...,2])*Yxy2[...,1]+Yxy3[...,1]*Yxyt[...,2]-Yxyt[...,1]*Yxy3[...,2])/a</span>
<span class="c1">#    m2 = -Yxy2[...,2]*((Yxyt[...,1]-Yxy3[...,1])*Yxy1[...,2]-(Yxyt[...,2]-Yxy3[...,2])*Yxy1[...,1]+Yxy3[...,1]*Yxyt[...,2]-Yxyt[...,1]*Yxy3[...,2])/a</span>
<span class="c1">#    m3 = Yxy3[...,2]*((Yxy2[...,1]-Yxy1[...,1])*Yxyt[...,2]-(Yxy2[...,2]-Yxy1[...,2])*Yxyt[...,1]+Yxy1[...,1]*Yxy2[...,2]-Yxy2[...,1]*Yxy1[...,2])/b</span>
<span class="c1">#    M = Yxyt[...,0]*np.vstack((m1/Yxy1[...,0],m2/Yxy2[...,0],m3/Yxy3[...,0]))</span>
    <span class="k">return</span> <span class="n">M</span><span class="o">.</span><span class="n">T</span></div>


<div class="viewcode-block" id="colormixer"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.colormixer">[docs]</a><span class="k">def</span> <span class="nf">colormixer</span><span class="p">(</span><span class="n">Yxyt</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">Yxyi</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">pair_strengths</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">source_order</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate fluxes required to obtain a target chromaticity </span>
<span class="sd">    when (additively) mixing N light sources.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :Yxyt: </span>
<span class="sd">            | ndarray with target Yxy chromaticities.</span>
<span class="sd">            | Defaults to equi-energy white.</span>
<span class="sd">        :Yxyi:</span>
<span class="sd">            | ndarray with Yxy chromaticities of light sources i = 1 to n.</span>
<span class="sd">        :n: </span>
<span class="sd">            | 4 or int, optional</span>
<span class="sd">            | Number of source components to randomly generate when Yxyi is None.</span>
<span class="sd">        :pair_strengths:</span>
<span class="sd">            | ndarray with light source pair strengths.  </span>
<span class="sd">        :source_order:</span>
<span class="sd">            | ndarray with order of source components.</span>
<span class="sd">            | If None: use np.arange(n)</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :M: </span>
<span class="sd">            | ndarray with fluxes.</span>
<span class="sd">    </span>
<span class="sd">    Note:</span>
<span class="sd">        :Algorithm:</span>
<span class="sd">            | 1. Loop over all source components and create intermediate sources</span>
<span class="sd">            |    from all (even,odd)-pairs using the relative strengths </span>
<span class="sd">            |     of the pair (specified in pair_strengths). </span>
<span class="sd">            | 2. Collect any remaining sources.</span>
<span class="sd">            | 3. Combine with new intermediate source components</span>
<span class="sd">            | 4. Repeat 1-3 until there are only 3 source components left. </span>
<span class="sd">            | 5. Use color3mixer to calculate the required fluxes of the 3 final</span>
<span class="sd">            |     intermediate components to obtain the target chromaticity. </span>
<span class="sd">            | 6. Backward calculate the fluxes of all original source components</span>
<span class="sd">            |     from the 3 final intermediate fluxes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">Yxyt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Yxyt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">Yxyi</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">Yxyi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">2</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">Yxyi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">pair_strengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">pair_strengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">source_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">source_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c1">#np.random.shuffle(source_order)</span>
        
    <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">ps</span> <span class="o">=</span> <span class="n">pair_strengths</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># relative pair_strengths of paired sources</span>
        <span class="n">so</span> <span class="o">=</span> <span class="n">source_order</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># all sources</span>
        <span class="n">N_sources</span> <span class="o">=</span> <span class="n">so</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># Pre-initialize:</span>
        <span class="n">mlut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">));</span> <span class="n">mlut</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">tmp_nan</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">));</span><span class="n">tmp_nan</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="n">mlut</span><span class="p">[:</span><span class="n">n</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">],</span> <span class="n">Yxyi</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>\
                           <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">],</span><span class="n">tmp_nan</span><span class="p">,</span>\
                           <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span><span class="n">tmp_nan</span><span class="p">))</span>
        <span class="n">sn_k</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
        <span class="n">su_k</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">n</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>  
        
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>   <span class="c1"># current state counter: </span>
                <span class="c1"># (states are loops runnning over all (even,odd) source component pairs.</span>
                <span class="c1"># After all pair intermediate sources have been made, any remaining source</span>
                <span class="c1"># components are collected and the state is reset running over </span>
                <span class="c1"># that new list of source components. Once there are only 3 </span>
                <span class="c1"># source components left, color3mixer is used to calculate the</span>
                <span class="c1"># required fluxes to obtain the target chromaticity. The fluxes </span>
                <span class="c1"># of all components are there calculate backward from the 3 fluxes.</span>
        <span class="n">kk</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># overall counter </span>
        <span class="k">while</span> <span class="p">(</span><span class="n">N_sources</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">kk</span><span class="o">&gt;</span><span class="n">n</span><span class="o">-</span><span class="mi">3</span><span class="p">):</span>
                
            <span class="c1"># Combine two sources:</span>
            <span class="n">pair_strength_AB</span> <span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="n">kk</span><span class="p">]</span>
            <span class="n">pA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">so</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="p">])</span>
            <span class="n">pB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">so</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">pAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">pA</span><span class="p">,</span><span class="n">pB</span><span class="p">))</span>
            
<span class="c1">#            xyzAB = Yxy_to_xyz(mlut[pAB,1:4])</span>
<span class="c1">#            YxyM = xyz_to_Yxy(pair_strength_AB * xyzAB[0,:] + (1 - pair_strength_AB) * xyzAB[1,:])[0]</span>
        
            <span class="c1"># About 20% faster than implementation above:</span>
            <span class="n">YxyA</span> <span class="o">=</span> <span class="n">mlut</span><span class="p">[</span><span class="n">pA</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">YxyB</span> <span class="o">=</span> <span class="n">mlut</span><span class="p">[</span><span class="n">pB</span><span class="p">,</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
            <span class="n">YA</span> <span class="o">=</span> <span class="n">YxyA</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xA</span> <span class="o">=</span> <span class="n">YxyA</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">yA</span> <span class="o">=</span> <span class="n">YxyA</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">YB</span> <span class="o">=</span> <span class="n">YxyB</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">xB</span> <span class="o">=</span> <span class="n">YxyB</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">yB</span> <span class="o">=</span> <span class="n">YxyB</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            
            <span class="n">XA</span> <span class="o">=</span> <span class="n">xA</span> <span class="o">*</span> <span class="n">YA</span> <span class="o">/</span> <span class="n">yA</span>
            <span class="n">XB</span> <span class="o">=</span> <span class="n">xB</span> <span class="o">*</span> <span class="n">YB</span> <span class="o">/</span> <span class="n">yB</span>
            <span class="n">ZA</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">xA</span> <span class="o">-</span> <span class="n">yA</span><span class="p">)</span> <span class="o">*</span> <span class="n">YA</span> <span class="o">/</span> <span class="n">yA</span>
            <span class="n">ZB</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">xB</span> <span class="o">-</span> <span class="n">yB</span><span class="p">)</span> <span class="o">*</span> <span class="n">YB</span> <span class="o">/</span> <span class="n">yB</span>

            <span class="n">XM</span> <span class="o">=</span> <span class="p">(</span><span class="n">pair_strength_AB</span> <span class="o">*</span> <span class="n">XA</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pair_strength_AB</span><span class="p">)</span> <span class="o">*</span> <span class="n">XB</span><span class="p">)</span>
            <span class="n">ZM</span> <span class="o">=</span> <span class="p">(</span><span class="n">pair_strength_AB</span> <span class="o">*</span> <span class="n">ZA</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pair_strength_AB</span><span class="p">)</span> <span class="o">*</span> <span class="n">ZB</span><span class="p">)</span>
            <span class="n">YM</span> <span class="o">=</span> <span class="p">(</span><span class="n">pair_strength_AB</span> <span class="o">*</span> <span class="n">YA</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pair_strength_AB</span><span class="p">)</span> <span class="o">*</span> <span class="n">YB</span><span class="p">)</span>
            <span class="n">xM</span> <span class="o">=</span> <span class="n">XM</span> <span class="o">/</span> <span class="p">(</span><span class="n">XM</span> <span class="o">+</span> <span class="n">YM</span> <span class="o">+</span> <span class="n">ZM</span><span class="p">)</span>
            <span class="n">yM</span> <span class="o">=</span> <span class="n">YM</span> <span class="o">/</span> <span class="p">(</span><span class="n">XM</span> <span class="o">+</span> <span class="n">YM</span> <span class="o">+</span> <span class="n">ZM</span><span class="p">)</span>
            <span class="n">YxyM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">YM</span><span class="p">,</span> <span class="n">xM</span><span class="p">,</span> <span class="n">yM</span><span class="p">))</span>        
        
            <span class="c1">#plt.plot(YxyM[1],YxyM[2],&#39;kd&#39;)</span>
        
            <span class="c1">#calculate the contributions of source 1 and source 2 needed to get the M of the temporary source</span>
            <span class="n">MA</span> <span class="o">=</span> <span class="n">pair_strength_AB</span> 
            <span class="n">MB</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">pair_strength_AB</span><span class="p">)</span>       
            <span class="n">mAB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">MA</span><span class="p">,</span><span class="n">MB</span><span class="p">))</span>
                        
            <span class="c1"># Do bookkeeping of components:</span>
            <span class="n">sn_k</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="n">kk</span>
            <span class="n">su_k</span><span class="p">[</span><span class="n">k</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">pAB</span>
            
            <span class="c1"># Store results in lut:</span>
            <span class="n">mlut</span><span class="p">[</span><span class="n">n</span> <span class="o">+</span> <span class="n">kk</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">n</span> <span class="o">+</span> <span class="n">kk</span><span class="p">,</span> <span class="n">YxyM</span><span class="p">,</span> <span class="n">pAB</span><span class="p">,</span> <span class="n">mAB</span><span class="p">))</span>

            <span class="c1"># Get remaining components:</span>
            <span class="n">rem_so</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">so</span><span class="p">,</span> <span class="n">su_k</span><span class="p">),</span><span class="n">sn_k</span><span class="p">))</span>
            <span class="n">rem_so</span> <span class="o">=</span> <span class="n">rem_so</span><span class="p">[</span><span class="n">rem_so</span><span class="o">&gt;=</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">N_sources</span> <span class="o">=</span> <span class="n">rem_so</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># Reset source list &#39;so&#39; when all pairs have been calculated for current state:</span>
            <span class="n">nn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">so</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">==</span> <span class="n">nn</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span> <span class="c1"># update to new state</span>
                <span class="n">sn_k</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nn</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
                <span class="n">su_k</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">nn</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span><span class="n">dtype</span> <span class="o">=</span> <span class="nb">int</span><span class="p">)</span>
                <span class="n">so</span> <span class="o">=</span> <span class="n">rem_so</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># add +1 to k:</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">kk</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># Calculate M3 using last 3 intermediate component sources:</span>
        <span class="n">M3</span> <span class="o">=</span> <span class="n">color3mixer</span><span class="p">(</span><span class="n">Yxyt</span><span class="p">,</span><span class="n">mlut</span><span class="p">[</span><span class="n">rem_so</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="n">mlut</span><span class="p">[</span><span class="n">rem_so</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="n">mlut</span><span class="p">[</span><span class="n">rem_so</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
        <span class="n">M3</span><span class="p">[</span><span class="n">M3</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
        <span class="c1"># Calculate fluxes backward from M3:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">))</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">M3</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">n_min</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span> <span class="p">(</span><span class="n">mlut</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">n_min</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">((</span><span class="n">n_min</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_min</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mlut</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">n_min</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">m3</span> <span class="o">=</span> <span class="n">M3</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="o">-</span><span class="n">k</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m3</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">pA</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">mlut</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span>
                <span class="n">pB</span> <span class="o">=</span> <span class="n">mlut</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
                <span class="n">mA</span> <span class="o">=</span> <span class="n">mlut</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span><span class="o">*</span><span class="n">m3</span>
                <span class="n">mB</span> <span class="o">=</span> <span class="n">mlut</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">7</span><span class="p">]</span><span class="o">*</span><span class="n">m3</span>
                <span class="n">mlut</span><span class="p">[</span><span class="n">pA</span><span class="p">,</span><span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">mlut</span><span class="p">[</span><span class="n">pA</span><span class="p">,</span><span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span><span class="o">*</span><span class="n">mA</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">pB</span><span class="p">):</span>
                    <span class="n">pB</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">pB</span><span class="p">)</span>
                    <span class="n">mlut</span><span class="p">[</span><span class="n">pB</span><span class="p">,</span><span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="n">mlut</span><span class="p">[</span><span class="n">pB</span><span class="p">,</span><span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span><span class="o">*</span><span class="n">mB</span>

                <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">M</span> <span class="o">=</span> <span class="n">mlut</span><span class="p">[:</span><span class="n">n</span><span class="p">,</span><span class="mi">6</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">M</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span> <span class="c1"># Use fast color3mixer</span>
        
        <span class="n">M</span> <span class="o">=</span> <span class="n">color3mixer</span><span class="p">(</span><span class="n">Yxyt</span><span class="p">,</span><span class="n">Yxyi</span><span class="p">[</span><span class="mi">0</span><span class="p">,:],</span><span class="n">Yxyi</span><span class="p">[</span><span class="mi">1</span><span class="p">,:],</span><span class="n">Yxyi</span><span class="p">[</span><span class="mi">2</span><span class="p">,:])</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">M</span><span class="p">)</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<span class="k">def</span> <span class="nf">_get_A_b_tv</span><span class="p">(</span><span class="n">xyzt</span><span class="p">,</span><span class="n">xyzi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Additive mixing using tristimulus values; solve Ax=b.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzt: </span>
<span class="sd">            | ndarray with target tristimulus values.</span>
<span class="sd">        :xyzi:</span>
<span class="sd">            | ndarray with tristimulus values of light sources i = 1 to n.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :A, b:</span>
<span class="sd">            | ndarrays A (3xn) and b (nx1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">xyzi</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">xyzt</span><span class="o">.</span><span class="n">T</span> <span class="c1"># A, b in Ax=b</span>

<span class="k">def</span> <span class="nf">_get_A_b_cc</span><span class="p">(</span><span class="n">Yxyt</span><span class="p">,</span><span class="n">Yxyi</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Additive mixing using chromaticity coordinates; solve Ax=b.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :Yxyt: </span>
<span class="sd">            | ndarray with target chromaticity coordinates.</span>
<span class="sd">        :Yxyi:</span>
<span class="sd">            | ndarray with chromaticity coordinates of light sources i = 1 to n.</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        :A, b:</span>
<span class="sd">            | ndarrays A (3xn) and b (nx1)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">A01j</span> <span class="o">=</span> <span class="p">((</span><span class="n">Yxyi</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">Yxyi</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">Yxyi</span><span class="o">-</span><span class="n">Yxyt</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">A2j</span> <span class="o">=</span> <span class="p">(</span><span class="n">Yxyi</span><span class="o">/</span><span class="n">Yxyt</span><span class="p">)[</span><span class="o">...</span><span class="p">,:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">A01j</span><span class="p">,</span><span class="n">A2j</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span><span class="o">.</span><span class="n">T</span> <span class="c1"># A, b in Ax=b</span>

<span class="k">def</span> <span class="nf">_solve_Ax_b</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve Ax=b using Moore-Penrose pseudo-inverse matrix (A.T@inv(A@A.T))</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :A, b:</span>
<span class="sd">            | ndarrays A (3xn) and b (nx1)</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :x:</span>
<span class="sd">            | ndarray with x</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="nd">@np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">A</span><span class="nd">@A</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="nd">@b</span>

<div class="viewcode-block" id="colormixer_pinv"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.colormixer_pinv">[docs]</a><span class="k">def</span> <span class="nf">colormixer_pinv</span><span class="p">(</span><span class="n">xyzt</span><span class="p">,</span> <span class="n">xyzi</span><span class="p">,</span> <span class="n">input_fmt</span> <span class="o">=</span> <span class="s1">&#39;xyz&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Additive color mixer of N primaries using using Moore-Penrose pseudo-inverse matrix.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :xyzt: </span>
<span class="sd">            | ndarray with target XYZ tristimulus values or Yxy chromaticity coordinates.</span>
<span class="sd">        :xyzi:</span>
<span class="sd">            | ndarray with XYZ tristimulus values or Yxy chromaticity coordinates of light sources i = 1 to n.</span>
<span class="sd">        :input_fmt:</span>
<span class="sd">            | &#39;xyz&#39;, optional</span>
<span class="sd">            | Format specifier of :xyzt: and :xyzi: input arguments.</span>
<span class="sd">            | - options: &#39;xyz&#39;, &#39;Yxy&#39;</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :w:</span>
<span class="sd">            | ndarray with fluxes (weights) of each of the primaries in the mixture.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">input_fmt</span> <span class="o">==</span> <span class="s1">&#39;xyz&#39;</span><span class="p">:</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_get_A_b_tv</span><span class="p">(</span><span class="n">xyzt</span><span class="p">,</span><span class="n">xyzi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">_get_A_b_cc</span><span class="p">(</span><span class="n">xyzt</span><span class="p">,</span><span class="n">xyzi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_solve_Ax_b</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">T</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="get_w_summed_spd"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.get_w_summed_spd">[docs]</a><span class="k">def</span> <span class="nf">get_w_summed_spd</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">spds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate weighted sum of spds.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :w: </span>
<span class="sd">            | ndarray with weigths (e.g. fluxes)</span>
<span class="sd">        :spds: </span>
<span class="sd">            | ndarray with component spds.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | ndarray with weighted sum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">spds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">w</span><span class="p">),</span><span class="n">spds</span><span class="p">[</span><span class="mi">1</span><span class="p">:])))</span></div>


<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="fitnessfcn"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.fitnessfcn">[docs]</a><span class="k">def</span> <span class="nf">fitnessfcn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">spd_constructor</span><span class="p">,</span> <span class="n">spd_constructor_pars</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">F_rss</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
               <span class="n">decimals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">obj_fcn</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">obj_fcn_pars</span> <span class="o">=</span> <span class="p">[{}],</span> 
               <span class="n">obj_fcn_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;F&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fitness function that calculates closeness of solution x to target values </span>
<span class="sd">    for specified objective functions.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | ndarray with parameter values</span>
<span class="sd">        :spd_constructor:</span>
<span class="sd">            | function handle to a function that constructs the spd</span>
<span class="sd">              from parameter values in :x:.</span>
<span class="sd">        :spd_constructor_pars:</span>
<span class="sd">            | None, optional,</span>
<span class="sd">            | Parameters required by :spd_constructor:</span>
<span class="sd">        :F_rss:</span>
<span class="sd">            | True, optional</span>
<span class="sd">            | Take Root-Sum-of-Squares of &#39;closeness&#39; values between target and </span>
<span class="sd">            | objective function values.</span>
<span class="sd">        :decimals:</span>
<span class="sd">            | 3, optional</span>
<span class="sd">            | List of rounding decimals of objective function values.</span>
<span class="sd">        :obj_fcn: </span>
<span class="sd">            | [None] or list, optional</span>
<span class="sd">            | List of function handles to objective function.</span>
<span class="sd">        :obj_fcn_weights:</span>
<span class="sd">            | [1] or list, optional.</span>
<span class="sd">            | List of weigths for each obj. fcn</span>
<span class="sd">        :obj_fcn_pars:</span>
<span class="sd">            | [None] or list, optional</span>
<span class="sd">            | List of parameter dicts for each obj. fcn.</span>
<span class="sd">        :obj_tar_vals:</span>
<span class="sd">            | [0] or list, optional</span>
<span class="sd">            | List of target values for each objective function.</span>
<span class="sd">        :verbosity:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | If &gt; 0: print intermediate results.</span>
<span class="sd">        :out: </span>
<span class="sd">            | &#39;F&#39;, optional</span>
<span class="sd">            | Determines output.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :F:</span>
<span class="sd">            | float or ndarray with fitness value for current solution :x:.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Keep track of solutions tried:</span>
    <span class="k">global</span> <span class="n">optcounter</span> 
    <span class="n">optcounter</span> <span class="o">=</span> <span class="n">optcounter</span> <span class="o">+</span> <span class="mi">1</span>
    
    <span class="c1"># Number of objective functions:</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_fcn</span><span class="p">)</span>
    
    <span class="c1"># Get current spdi:</span>
    <span class="n">spdi</span><span class="p">,</span><span class="n">args_out</span><span class="p">,</span><span class="n">component_spds</span> <span class="o">=</span> <span class="n">spd_constructor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">spd_constructor_pars</span><span class="p">)</span> 

    <span class="c1"># Goodness-of-fit:</span>
    <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">));</span> <span class="n">F</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
    <span class="n">obj_vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">]</span><span class="o">*</span><span class="n">N</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">spdi</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()):</span>
        <span class="n">F</span> <span class="o">=</span> <span class="mi">10000000</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        
        <span class="c1"># Make decimals and obj_fcn_weights same size as N:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">decimals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">decimals</span> <span class="o">=</span>  <span class="n">decimals</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">N</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_fcn_weights</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">obj_fcn_weights</span> <span class="o">=</span>  <span class="n">obj_fcn_weights</span><span class="o">*</span><span class="n">N</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj_fcn_pars</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> 
            <span class="n">obj_fcn_pars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj_fcn_pars</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
        <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">obj_tar_vals</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">object</span><span class="p">)</span>
        
        <span class="c1"># Calculate all objective functions and closeness to target values</span>
        <span class="c1"># store squared weighted differences for speed:</span>
        <span class="n">output_str_start</span> <span class="o">=</span> <span class="s1">&#39;c</span><span class="si">{:1.0f}</span><span class="s1">: F = {:1.&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{:1.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;f}&#39;</span> <span class="o">+</span> <span class="s1">&#39; : &#39;</span>
        <span class="n">output_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">obj_fcn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj_fcn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">obj_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj_fcn</span><span class="p">[</span><span class="n">i</span><span class="p">](</span><span class="n">spdi</span><span class="p">,</span> <span class="o">**</span><span class="n">obj_fcn_pars</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">obj_tar_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">f_normalize</span> <span class="o">=</span> <span class="n">obj_tar_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">f_normalize</span> <span class="o">=</span> <span class="mi">1</span>
                        
                    <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj_fcn_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">obj_vals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">decimals</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">-</span> <span class="n">obj_tar_vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">f_normalize</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                    
                    <span class="k">if</span> <span class="p">(</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">output_str</span> <span class="o">=</span> <span class="n">output_str</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39; obj_#</span><span class="si">{:1.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; = {:1.&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{:1.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">decimals</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">+</span> <span class="s1">&#39;f},&#39;</span>
                        <span class="n">output_str</span> <span class="o">=</span> <span class="n">output_str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">obj_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Execute function (first tuple element) only once and output desired values to save time:</span>
                    <span class="n">obj_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj_fcn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">](</span><span class="n">spdi</span><span class="p">,</span> <span class="o">**</span><span class="n">obj_fcn_pars</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                    <span class="n">obj_tar_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">obj_tar_vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">f_normalize</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">obj_tar_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1"># obj_tar_vals[i] must also be tuple!!</span>
                    <span class="n">f_normalize</span><span class="p">[</span><span class="n">obj_tar_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj_tar_vals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">obj_tar_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">decimals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">decimals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">obj_fcn_weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">obj_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mi">10</span><span class="o">**</span><span class="n">decimals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="mi">10</span><span class="o">**</span><span class="n">decimals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">obj_tar_vals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">f_normalize</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># obj_fcn_weights[i], obj_tar_vals[i] must be tuple!!!</span>
                  
                    <span class="k">if</span> <span class="p">(</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">output_str_sub</span> <span class="o">=</span> <span class="s1">&#39;(&#39;</span>
                        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">obj_fcn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">output_str_sub</span> <span class="o">=</span> <span class="n">output_str_sub</span> <span class="o">+</span> <span class="n">obj_fcn</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">jj</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39; = {:1.&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{:1.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">decimals</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">jj</span><span class="p">]))</span> <span class="o">+</span> <span class="s1">&#39;f},&#39;</span>
                        <span class="n">output_str_sub</span> <span class="o">=</span> <span class="n">output_str_sub</span> <span class="o">+</span> <span class="s1">&#39;)&#39;</span>
                        <span class="n">output_str_sub</span> <span class="o">=</span> <span class="n">output_str_sub</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">obj_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>    
                        <span class="n">output_str</span> <span class="o">=</span> <span class="n">output_str</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39; obj_#</span><span class="si">{:1.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; = {:1.&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{:1.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">decimals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()))</span> <span class="o">+</span> <span class="s1">&#39;f} &#39;</span> <span class="o">+</span> <span class="n">output_str_sub</span> <span class="o">+</span> <span class="s1">&#39;,&#39;</span>
                        <span class="n">output_str</span> <span class="o">=</span> <span class="n">output_str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">F</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                
                <span class="k">if</span> <span class="p">(</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">output_str</span> <span class="o">=</span> <span class="n">output_str</span> <span class="o">+</span> <span class="sa">r</span><span class="s1">&#39; obj_#</span><span class="si">{:1.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39; = NaN,&#39;</span>
    
        <span class="c1"># Print intermediate results:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">verbosity</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">output_str</span> <span class="o">=</span> <span class="n">output_str_start</span> <span class="o">+</span> <span class="n">output_str</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">output_str</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">optcounter</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">F</span><span class="p">))))))</span>
    
    <span class="c1"># Take Root-Sum-of-Squares of delta((val - tar)**2):</span>
    <span class="k">if</span> <span class="n">F_rss</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">F</span><span class="p">))</span>

    
    <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;F&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">F</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;args_out&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">args_out</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;obj_vals&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj_vals</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;F,obj_vals&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">F</span><span class="p">,</span> <span class="n">obj_vals</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;spdi,obj_vals&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spdi</span><span class="p">,</span> <span class="n">obj_vals</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;spdi,args_out&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spdi</span><span class="p">,</span> <span class="n">args_out</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;spdi,args_out,component_spds&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spdi</span><span class="p">,</span> <span class="n">args_out</span><span class="p">,</span> <span class="n">component_spds</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;spdi,obj_vals,args_out&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spdi</span><span class="p">,</span><span class="n">obj_vals</span><span class="p">,</span><span class="n">args_out</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;spdi,obj_vals,args_out,component_spds&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spdi</span><span class="p">,</span><span class="n">obj_vals</span><span class="p">,</span><span class="n">args_out</span><span class="p">,</span><span class="n">component_spds</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">eval</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>
        


<div class="viewcode-block" id="spd_constructor_2"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.spd_constructor_2">[docs]</a><span class="k">def</span> <span class="nf">spd_constructor_2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">constructor_pars</span> <span class="o">=</span> <span class="p">{},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct spd from model parameters using pairs of intermediate sources.</span>
<span class="sd">    </span>
<span class="sd">    | Pairs (odd,even) of components are selected and combined using </span>
<span class="sd">    |  &#39;pair_strength&#39;. This process is continued until only 3 intermediate </span>
<span class="sd">    |  (combined) sources remain. Color3mixer is then used to calculate the </span>
<span class="sd">    |  fluxes for the remaining 3 sources, after which the fluxes of all </span>
<span class="sd">    |  components are back-calculated.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x: </span>
<span class="sd">            | vector of optimization parameters.</span>
<span class="sd">        :constructor_pars: </span>
<span class="sd">            | dict with model parameters. </span>
<span class="sd">            | Key &#39;list&#39; determines which parameters are in :x: and key &#39;len&#39;</span>
<span class="sd">            | (Specifies the number of variables representing each parameter).</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | spd, M, spds</span>
<span class="sd">            | ndarrays with spectrum corresponding to x, M the fluxes of </span>
<span class="sd">            | the spectral components of spd and spds the spectral components </span>
<span class="sd">            | themselves.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="n">constructor_pars</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
    <span class="c1"># replace / init cp with values from x (parameters to optimize)</span>
    <span class="c1"># (opt_list and opt_len refer resp. to the key in cp and the length</span>
    <span class="c1"># of that parameter in x)</span>
    <span class="n">cp</span><span class="p">,</span> <span class="n">vsize</span> <span class="o">=</span> <span class="n">vec_to_dict</span><span class="p">(</span><span class="n">vec</span><span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">dic</span> <span class="o">=</span> <span class="n">cp</span><span class="p">,</span> <span class="n">vsize</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">],</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">])</span>

    <span class="n">spd</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">component_spds</span> <span class="o">=</span> <span class="n">spd_builder</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;peakwl&#39;</span><span class="p">],</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">],</span>\
                                      <span class="n">bw_order</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;bw_order&#39;</span><span class="p">],</span>\
                                       <span class="n">pair_strengths</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;pair_strengths&#39;</span><span class="p">],</span>\
                                      <span class="n">strength_shoulder</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;strength_shoulder&#39;</span><span class="p">],</span>\
                                      <span class="n">target</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">],</span> <span class="n">tar_type</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;tar_type&#39;</span><span class="p">],</span>\
                                      <span class="n">cspace_bwtf</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;cspace_bwtf&#39;</span><span class="p">],</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;cieobs&#39;</span><span class="p">],</span>\
                                      <span class="n">use_piecewise_fcn</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;use_piecewise_fcn&#39;</span><span class="p">],</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;wl&#39;</span><span class="p">],</span>\
                                      <span class="n">component_spds</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;component_spds&#39;</span><span class="p">],</span>\
                                      <span class="n">strength_ph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                                      <span class="n">peakwl_ph1</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fwhm_ph1</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_ph1</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                                      <span class="n">peakwl_ph2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fwhm_ph2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_ph2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                                      <span class="n">flux</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;spd,M,component_spds&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
   
    <span class="n">spds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">component_spds</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">spds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">spd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">spds</span><span class="p">))</span> <span class="c1"># store component spectra in spds with first axis components, second axis wavelengths</span>

    <span class="c1"># Calculate  SPD:</span>
    <span class="n">spd</span> <span class="o">=</span> <span class="n">get_w_summed_spd</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">spds</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">spd</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">spds</span></div>



<div class="viewcode-block" id="spd_constructor_3"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.spd_constructor_3">[docs]</a><span class="k">def</span> <span class="nf">spd_constructor_3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">constructor_pars</span> <span class="o">=</span> <span class="p">{},</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct spd from model parameters using trio&#39;s of intermediate sources.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    | The triangle/trio method creates for all possible combinations of 3 primary</span>
<span class="sd">    | component spectra a spectrum that results in the target chromaticity </span>
<span class="sd">    | using color3mixer() and then optimizes the weights of each of the latter </span>
<span class="sd">    | spectra such that adding them (additive mixing) results in obj_vals as </span>
<span class="sd">    | close as possible to the target values.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :x:</span>
<span class="sd">            | vector of optimization parameters.</span>
<span class="sd">        :constructor_pars:</span>
<span class="sd">            | dict with model parameters. </span>
<span class="sd">            | Key &#39;list&#39; determines which parameters are in :x: and key &#39;len&#39;</span>
<span class="sd">            | (specifies the number of variables representing each parameter).</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | spd, M, spds</span>
<span class="sd">            | ndarrays with spectrum corresponding to x, M the fluxes of </span>
<span class="sd">            | the spectral components of spd and spds the spectral components </span>
<span class="sd">            | themselves.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cp</span> <span class="o">=</span> <span class="n">constructor_pars</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="c1"># replace / init cp with values from x (parameters to optimize)</span>
    <span class="c1"># (opt_list and opt_len refer resp. to the key in cp and the length</span>
    <span class="c1"># of that parameter in x)</span>
    <span class="n">cp</span><span class="p">,</span> <span class="n">vsize</span> <span class="o">=</span> <span class="n">vec_to_dict</span><span class="p">(</span><span class="n">vec</span><span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">dic</span> <span class="o">=</span> <span class="n">cp</span><span class="p">,</span> <span class="n">vsize</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">],</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">])</span>

    <span class="n">target</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1">#only calculate component spectra</span>
    <span class="n">Yxy_target</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span>
    <span class="n">spd</span><span class="p">,</span> <span class="n">component_spds</span> <span class="o">=</span> <span class="n">spd_builder</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;peakwl&#39;</span><span class="p">],</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">],</span>\
                                      <span class="n">bw_order</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;bw_order&#39;</span><span class="p">],</span>\
                                      <span class="n">pair_strengths</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;pair_strengths&#39;</span><span class="p">],</span>\
                                      <span class="n">strength_shoulder</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;strength_shoulder&#39;</span><span class="p">],</span>\
                                      <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">,</span> <span class="n">tar_type</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;tar_type&#39;</span><span class="p">],</span>\
                                      <span class="n">cspace_bwtf</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;cspace_bwtf&#39;</span><span class="p">],</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;cieobs&#39;</span><span class="p">],</span>\
                                      <span class="n">use_piecewise_fcn</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;use_piecewise_fcn&#39;</span><span class="p">],</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;wl&#39;</span><span class="p">],</span>\
                                      <span class="n">component_spds</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;component_spds&#39;</span><span class="p">],</span>\
                                      <span class="n">strength_ph</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                                      <span class="n">peakwl_ph1</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fwhm_ph1</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_ph1</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                                      <span class="n">peakwl_ph2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">fwhm_ph2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">strength_ph2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                                      <span class="n">flux</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">with_wl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;spd,component_spds&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="n">spds</span> <span class="o">=</span> <span class="n">spd</span> <span class="c1"># component spds in Nxwl format</span>
    
    <span class="c1"># Calculate xyzi and Yxyi of component spectra:</span>
    <span class="n">xyzi</span> <span class="o">=</span> <span class="n">spd_to_xyz</span><span class="p">(</span><span class="n">spds</span><span class="p">,</span> <span class="n">relative</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;cieobs&#39;</span><span class="p">])</span>
    <span class="n">Yxyi</span> <span class="o">=</span> <span class="n">xyz_to_Yxy</span><span class="p">(</span><span class="n">xyzi</span><span class="p">)</span>

    <span class="c1"># Generate all possible 3-channel combinations (component triangles):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">Yxyi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">combos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">),</span> <span class="mi">3</span><span class="p">)))</span> 
   
    <span class="c1"># calculate fluxes to obtain target Yxyt:</span>
    <span class="n">M3</span> <span class="o">=</span> <span class="n">color3mixer</span><span class="p">(</span><span class="n">Yxy_target</span><span class="p">,</span><span class="n">Yxyi</span><span class="p">[</span><span class="n">combos</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],:],</span><span class="n">Yxyi</span><span class="p">[</span><span class="n">combos</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],:],</span><span class="n">Yxyi</span><span class="p">[</span><span class="n">combos</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],:])</span>
        
    <span class="c1"># Get rid of out-of-gamut solutions:</span>
    <span class="n">is_out_of_gamut</span> <span class="o">=</span>  <span class="p">(((</span><span class="n">M3</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">M3</span><span class="p">[</span><span class="n">is_out_of_gamut</span><span class="p">,:]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Nc</span> <span class="o">=</span> <span class="n">combos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">M3</span><span class="p">[</span><span class="n">is_out_of_gamut</span><span class="p">,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">if</span> <span class="n">Nc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Calulate fluxes of all components from M3 and x_final:            </span>
        <span class="n">M_final</span> <span class="o">=</span> <span class="n">cp</span><span class="p">[</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">][:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">M3</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">N</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">M</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">M_final</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">combos</span> <span class="o">==</span> <span class="n">i</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">M3</span>
    
    <span class="c1"># Calculate optimized SPD:</span>
    <span class="n">spd</span> <span class="o">=</span> <span class="n">get_w_summed_spd</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">spds</span><span class="p">)</span>
    
    <span class="c1"># When all out-of-gamut: set spd to NaN&#39;s:</span>
    <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">spd</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        
    <span class="k">return</span> <span class="n">spd</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">spds</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="spd_optimizer_2_3"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.spd_optimizer_2_3">[docs]</a><span class="k">def</span> <span class="nf">spd_optimizer_2_3</span><span class="p">(</span><span class="n">optimizer_type</span> <span class="o">=</span> <span class="s1">&#39;2mixer&#39;</span><span class="p">,</span> \
                    <span class="n">spd_constructor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                    <span class="n">component_data</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">N_components</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">,</span>\
                    <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>\
                    <span class="n">Yxy_target</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">]),</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span>\
                    <span class="n">obj_fcn</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">obj_fcn_pars</span> <span class="o">=</span> <span class="p">[{}],</span> <span class="n">obj_fcn_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>\
                    <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">decimals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> \
                    <span class="n">minimize_method</span> <span class="o">=</span> <span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">,</span> <span class="n">minimize_opts</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">F_rss</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>\
                    <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    | Optimizes the weights (fluxes) of a set of component spectra by combining </span>
<span class="sd">    | pairs (2) or trio&#39;s (3) of components to intermediate sources until only 3</span>
<span class="sd">    | remain. Color3mixer can then be called to calculate required fluxes to</span>
<span class="sd">    | obtain target chromaticity and fluxes are then back-calculated.</span>

<span class="sd">    Args:</span>
<span class="sd">        :optimizer_type: </span>
<span class="sd">            | &#39;2mixer&#39; or &#39;3mixer&#39; or &#39;user&#39;, optional</span>
<span class="sd">            | Specifies whether to optimize spectral model parameters by </span>
<span class="sd">            | combining pairs or trio&#39;s of comonponents.</span>
<span class="sd">        :spd_constructor: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Function handle to user defined spd_constructor function.</span>
<span class="sd">            |     Input: fcn(x, constructor_pars = {}, kwargs)</span>
<span class="sd">            |     Output: spd,M,spds</span>
<span class="sd">            |         nd array with:</span>
<span class="sd">            |             - spd: spectrum resulting from x</span>
<span class="sd">            |            - M: fluxes of all component spds</span>
<span class="sd">            |             - spds: component spds (in [N+1,wl] format)</span>
<span class="sd">            | (See e.g. spd_constructor_2 or spd_constructor_3)</span>
<span class="sd">        :spd_model_pars: </span>
<span class="sd">            | dict with model parameters required by spd_constructor</span>
<span class="sd">            | and with optimization parameters required by minimize (x0, lb, ub).                .</span>
<span class="sd">            | Only used when :optimizer_type: == &#39;user&#39;.</span>
<span class="sd">        :component_data:</span>
<span class="sd">            | 4, optional</span>
<span class="sd">            | Component spectra data: </span>
<span class="sd">            | If int: specifies number of components used in optimization </span>
<span class="sd">            |         (peakwl, fwhm and pair_strengths will be optimized).</span>
<span class="sd">            | If dict: generate components based on parameters (peakwl, fwhm, </span>
<span class="sd">            |          pair_strengths, etc.) in dict. </span>
<span class="sd">            |         (keys with None values will be optimized)</span>
<span class="sd">            | If ndarray: optimize pair_strengths of component spectra.</span>
<span class="sd">        :N_components:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Specifies number of components used in optimization. (only used </span>
<span class="sd">            | when :component_data: is dict and user wants to override dict. </span>
<span class="sd">            | Note that shape of parameters arrays must match N_components).</span>
<span class="sd">        :allow_nongaussianbased_mono_spds: </span>
<span class="sd">            | False, optional</span>
<span class="sd">            | False: use pure Gaussian based monochrom. spds.</span>
<span class="sd">        :wl:</span>
<span class="sd">            | _WL3, optional</span>
<span class="sd">            | Wavelengths used in optimization when :component_data: is not </span>
<span class="sd">            | ndarray with spectral data.</span>
<span class="sd">        :Yxy_target:</span>
<span class="sd">            | np2d([100,1/3,1/3]), optional</span>
<span class="sd">            | ndarray with Yxy chromaticity of target.</span>
<span class="sd">        :cieobs:</span>
<span class="sd">            | _CIEOBS, optional</span>
<span class="sd">            | CIE CMF set used to calculate chromaticity values if not provided </span>
<span class="sd">            | in :Yxyi:.</span>
<span class="sd">        :F_rss: </span>
<span class="sd">            | True, optional</span>
<span class="sd">            | Take Root-Sum-of-Squares of &#39;closeness&#39; values between target and </span>
<span class="sd">            | objective function values.</span>
<span class="sd">        :decimals:</span>
<span class="sd">            | 5, optional</span>
<span class="sd">            | Rounding decimals of objective function values.</span>
<span class="sd">        :obj_fcn: </span>
<span class="sd">            | [None] or list, optional</span>
<span class="sd">            | Function handles to objective function.</span>
<span class="sd">        :obj_fcn_weights:</span>
<span class="sd">            | [1] or list, optional.</span>
<span class="sd">            | Weigths for each obj. fcn</span>
<span class="sd">        :obj_fcn_pars:</span>
<span class="sd">            | [None] or list, optional</span>
<span class="sd">            | Parameter dicts for each obj. fcn.</span>
<span class="sd">        :obj_tar_vals:</span>
<span class="sd">            | [0] or list, optional</span>
<span class="sd">            | Target values for each objective function.</span>
<span class="sd">        :minimize_method:</span>
<span class="sd">            | &#39;Nelder-Mead&#39;, optional</span>
<span class="sd">            | Optimization method used by minimize function.</span>
<span class="sd">        :minimize_opts: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dict with minimization options. </span>
<span class="sd">            | None defaults to: {&#39;xtol&#39;: 1e-5, &#39;disp&#39;: True, &#39;maxiter&#39;: 1000*Nc,</span>
<span class="sd">            |                     &#39;maxfev&#39; : 1000*Nc,&#39;fatol&#39;: 0.01}</span>
<span class="sd">        :verbosity:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | If &gt; 0: print intermediate results.</span>

<span class="sd">    Returns:</span>
<span class="sd">        :returns:</span>
<span class="sd">            | M, spd_opt, obj_vals</span>
<span class="sd">            |   - &#39;M&#39;: ndarray with fluxes for each component spectrum.</span>
<span class="sd">            |   - &#39;spd_opt&#39;: optimized spectrum.</span>
<span class="sd">            |   - &#39;obj_vals&#39;: values of the obj. fcns for the optimized spectrum.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Set spd_constructor function:</span>
    <span class="k">if</span> <span class="n">optimizer_type</span> <span class="o">==</span> <span class="s1">&#39;2mixer&#39;</span><span class="p">:</span>
        <span class="n">spd_constructor</span> <span class="o">=</span> <span class="n">spd_constructor_2</span>
    <span class="k">elif</span> <span class="n">optimizer_type</span> <span class="o">==</span> <span class="s1">&#39;3mixer&#39;</span><span class="p">:</span>
        <span class="n">spd_constructor</span> <span class="o">=</span> <span class="n">spd_constructor_3</span>
    <span class="k">elif</span> <span class="n">optimizer_type</span> <span class="o">==</span> <span class="s1">&#39;search&#39;</span><span class="p">:</span> <span class="c1"># Optimize fluxes and component model parameters (chromaticity is part of obj_fcn list)</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;spd_optimizer_2_3(): optimizer_type = &#39;search&#39; not yet implemented. Use &#39;2mixer&#39; or &#39;3mixer&#39;. &quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">optimizer_type</span> <span class="o">==</span> <span class="s1">&#39;user&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">spd_constructor</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;spd_to_optimizer_2_3(): No user defined spd_constructor found.&#39;</span><span class="p">)</span>
    
    <span class="c1"># Initialize  spd_model_pars and spd_optim_pars:</span>
    <span class="k">if</span> <span class="n">optimizer_type</span> <span class="o">!=</span> <span class="s1">&#39;user&#39;</span><span class="p">:</span>
        <span class="n">spd_optim_pars</span><span class="p">,</span> <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="n">initialize_spd_optim_pars</span><span class="p">(</span><span class="n">component_data</span><span class="p">,</span> \
                                                                   <span class="n">optimizer_type</span> <span class="o">=</span> <span class="n">optimizer_type</span><span class="p">,</span> \
                                                                   <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="n">allow_nongaussianbased_mono_spds</span><span class="p">,</span> \
                                                                   <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span>\
                                                                   <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="n">spd_model_pars</span><span class="p">)</span>        
        <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">spd_model_pars</span><span class="p">,</span> <span class="o">**</span><span class="n">spd_optim_pars</span><span class="p">}</span> <span class="c1"># merge two dicts</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;x0&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spd_model_pars</span><span class="p">:</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;LB&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spd_model_pars</span><span class="p">:</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="s1">&#39;UB&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">spd_model_pars</span><span class="p">:</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Also store the following args in spd_constructor_pars (needed by spd_constructor):</span>
    <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Yxy_target</span>
    <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;tar_type&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Yxy&#39;</span>
    <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;cspace_bwtf&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;cieobs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">cieobs</span>
    
    <span class="c1"># Get starting value, lower and upper bounds:</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span>
    <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">],</span> <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">])</span>

    <span class="c1"># Setup optimization:</span>
    <span class="k">global</span> <span class="n">optcounter</span>
    <span class="n">optcounter</span> <span class="o">=</span> <span class="mi">1</span>     

    <span class="k">if</span> <span class="n">minimize_opts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">minimize_opts</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;xtol&#39;</span><span class="p">:</span> <span class="mf">1e-5</span><span class="p">,</span> <span class="s1">&#39;disp&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s1">&#39;maxiter&#39;</span> <span class="p">:</span> <span class="mi">1000</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span> <span class="s1">&#39;maxfev&#39;</span> <span class="p">:</span> <span class="mi">1000</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x0</span><span class="p">),</span><span class="s1">&#39;fatol&#39;</span><span class="p">:</span> <span class="mf">0.01</span><span class="p">}</span>
    <span class="n">input_par</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">spd_constructor</span><span class="p">,</span> <span class="n">spd_model_pars</span><span class="p">,</span> <span class="n">obj_fcn</span><span class="p">,</span> <span class="n">obj_fcn_pars</span><span class="p">,</span> <span class="n">obj_fcn_weights</span><span class="p">,</span> <span class="n">obj_tar_vals</span><span class="p">,</span> <span class="n">F_rss</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">verbosity</span><span class="p">)</span>
      
    <span class="c1"># Create positional argument only function for scipy.minimize():</span>
    <span class="k">def</span> <span class="nf">fit_fcn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">spd_constructor</span><span class="p">,</span> <span class="n">spd_model_pars</span><span class="p">,</span>  <span class="n">obj_fcn</span><span class="p">,</span> <span class="n">obj_fcn_pars</span><span class="p">,</span> <span class="n">obj_fcn_weights</span><span class="p">,</span> <span class="n">obj_tar_vals</span><span class="p">,</span> <span class="n">F_rss</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">verbosity</span><span class="p">):</span>
        <span class="n">F</span> <span class="o">=</span> <span class="n">fitnessfcn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">spd_constructor</span><span class="p">,</span> <span class="n">spd_constructor_pars</span> <span class="o">=</span> <span class="n">spd_model_pars</span><span class="p">,</span>\
                  <span class="n">F_rss</span> <span class="o">=</span> <span class="n">F_rss</span><span class="p">,</span> <span class="n">decimals</span> <span class="o">=</span> <span class="n">decimals</span><span class="p">,</span>\
                  <span class="n">obj_fcn</span> <span class="o">=</span> <span class="n">obj_fcn</span><span class="p">,</span> <span class="n">obj_fcn_pars</span> <span class="o">=</span> <span class="n">obj_fcn_pars</span><span class="p">,</span> <span class="n">obj_fcn_weights</span> <span class="o">=</span> <span class="n">obj_fcn_weights</span><span class="p">,</span>\
                  <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="n">obj_tar_vals</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="n">verbosity</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">F</span>

    <span class="c1"># Perform optimzation:</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">minimizebnd</span><span class="p">(</span><span class="n">fit_fcn</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">args</span> <span class="o">=</span> <span class="n">input_par</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="n">minimize_method</span><span class="p">,</span> <span class="n">use_bnd</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span> <span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="n">minimize_opts</span><span class="p">)</span>
    <span class="n">x_final</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">])</span>
   
    <span class="c1"># Calculate optimized SPD and get obj_vals and fluxes:</span>
    <span class="n">spd_opt</span><span class="p">,</span> <span class="n">obj_vals</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">component_spds</span> <span class="o">=</span> <span class="n">fit_fcn</span><span class="p">(</span><span class="n">x_final</span><span class="p">,</span> <span class="s1">&#39;spdi,obj_vals,args_out,component_spds&#39;</span><span class="p">,</span> <span class="n">spd_constructor</span><span class="p">,</span> <span class="n">spd_model_pars</span><span class="p">,</span> <span class="n">obj_fcn</span><span class="p">,</span> <span class="n">obj_fcn_pars</span><span class="p">,</span> <span class="n">obj_fcn_weights</span><span class="p">,</span> <span class="n">obj_tar_vals</span><span class="p">,</span> <span class="n">F_rss</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">verbosity</span><span class="p">)</span>
    
    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;obj_vals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj_vals</span>
    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;x_final&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_final</span>
    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;spd_opt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">spd_opt</span>
    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span>
    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;component_spds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">component_spds</span>
    
    <span class="k">return</span> <span class="n">spd_opt</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">component_spds</span><span class="p">,</span> <span class="n">obj_vals</span><span class="p">,</span> <span class="n">res</span></div>
        

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="get_optim_pars_dict"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.get_optim_pars_dict">[docs]</a><span class="k">def</span> <span class="nf">get_optim_pars_dict</span><span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">]),</span> <span class="n">tar_type</span> <span class="o">=</span> <span class="s1">&#39;Yxy&#39;</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span>\
              <span class="n">optimizer_type</span> <span class="o">=</span> <span class="s1">&#39;2mixer&#39;</span><span class="p">,</span> <span class="n">spd_constructor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
              <span class="n">cspace</span> <span class="o">=</span> <span class="s1">&#39;Yuv&#39;</span><span class="p">,</span> <span class="n">cspace_bwtf</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">cspace_fwtf</span> <span class="o">=</span> <span class="p">{},</span>\
              <span class="n">component_spds</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">N_components</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
              <span class="n">obj_fcn</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">obj_fcn_pars</span> <span class="o">=</span> <span class="p">[{}],</span> <span class="n">obj_fcn_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>\
              <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">decimals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> \
              <span class="n">minimize_method</span> <span class="o">=</span> <span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">,</span> <span class="n">minimize_opts</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">F_rss</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>\
              <span class="n">peakwl</span> <span class="o">=</span> <span class="p">[</span><span class="mi">450</span><span class="p">,</span><span class="mi">530</span><span class="p">,</span><span class="mi">610</span><span class="p">],</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">],</span> \
              <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">bw_order</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>\
              <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">strength_shoulder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>\
              <span class="n">strength_ph</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">use_piecewise_fcn</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>\
              <span class="n">peakwl_ph1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">530</span><span class="p">],</span> <span class="n">fwhm_ph1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">80</span><span class="p">],</span> <span class="n">strength_ph1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>\
              <span class="n">peakwl_ph2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">560</span><span class="p">],</span> <span class="n">fwhm_ph2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">80</span><span class="p">],</span> <span class="n">strength_ph2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
              <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>\
              <span class="n">pair_strengths</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">triangle_strengths</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
              <span class="n">peakwl_min</span> <span class="o">=</span> <span class="p">[</span><span class="mi">400</span><span class="p">],</span> <span class="n">peakwl_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">700</span><span class="p">],</span>\
              <span class="n">fwhm_min</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">fwhm_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">600</span><span class="p">],</span>\
              <span class="n">bw_order_min</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">bw_order_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">]):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Setup dict with optimization parameters.</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        See  ?spd_optimizer for more info. </span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :opts: </span>
<span class="sd">            | dict with keys and values of the function&#39;s keywords and values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">opts</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span>
    <span class="n">spd_models_pars</span> <span class="o">=</span> <span class="n">opts</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;spd_model_pars&#39;</span><span class="p">)</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">getwlr</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
    
    <span class="c1"># Set number of component sources:</span>
    <span class="k">if</span> <span class="n">component_spds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">N_components</span> <span class="o">=</span> <span class="n">component_spds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">N_components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">N_components</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peakwl</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">N_components</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;optim_dict(): Optimization requires at least 3 component sources.&#39;</span><span class="p">)</span>

    
    <span class="c1"># Ensure sufficient length of peakw if input comes from component_spds or N_components:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fwhm</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N_components</span><span class="p">:</span>
        <span class="n">fwhm</span> <span class="o">=</span> <span class="p">(</span><span class="n">wl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">wl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">N_components</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_components</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fwhm</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">fwhm_min</span><span class="p">):</span>
            <span class="n">fwhm</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fwhm_min</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_components</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peakwl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N_components</span><span class="p">:</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">peakwl_max</span><span class="p">)</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">peakwl_min</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">N_components</span><span class="p">)</span>
        <span class="n">peakwl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">peakwl_min</span><span class="p">)</span><span class="o">+</span><span class="n">dd</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">peakwl_max</span><span class="p">)</span><span class="o">-</span><span class="n">dd</span><span class="p">,</span> <span class="n">N_components</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bw_order</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N_components</span><span class="p">:</span>
            <span class="n">bw_order</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bw_order_min</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_components</span><span class="p">)</span>
    
    <span class="c1"># Set max and min values:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peakwl_min</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peakwl</span><span class="p">):</span>
        <span class="n">peakwl_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">peakwl_min</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_components</span><span class="p">)</span>
        <span class="n">peakwl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">([</span><span class="n">peakwl_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">peakwl</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_components</span><span class="p">)]</span> <span class="c1">#ensure values are within bounds</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peakwl_max</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">peakwl</span><span class="p">):</span>
        <span class="n">peakwl_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">peakwl_max</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_components</span><span class="p">)</span>
        <span class="n">peakwl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">([</span><span class="n">peakwl_max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">peakwl</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_components</span><span class="p">)]</span> <span class="c1">#ensure values are within bounds</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fwhm_min</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fwhm</span><span class="p">):</span>
        <span class="n">fwhm_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">fwhm_min</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_components</span><span class="p">)</span>
        <span class="n">fwhm</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">([</span><span class="n">fwhm_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">fwhm</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_components</span><span class="p">)]</span> <span class="c1">#ensure values are within bounds</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fwhm_max</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fwhm</span><span class="p">):</span>
        <span class="n">fwhm_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">fwhm_max</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_components</span><span class="p">)</span>
        <span class="n">fwhm</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">([</span><span class="n">fwhm_max</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">fwhm</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_components</span><span class="p">)]</span> <span class="c1">#ensure values are within bounds</span>
    
    <span class="k">if</span> <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span> <span class="c1"># do nothing, no non-gaussian based profile requested</span>
        <span class="n">bw_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">bw_order</span><span class="p">)</span> <span class="c1"># convert to ndarray for boolean slicing</span>
        <span class="c1">#bw_order[bw_order == -1] = 0 #0 also results in Ohno based on pure gaussian</span>
        <span class="n">bw_order</span> <span class="o">=</span> <span class="n">bw_order</span><span class="o">.</span><span class="n">tolist</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># convert back to list for normal processing</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bw_order_max</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bw_order</span><span class="p">)):</span>
            <span class="n">bw_order_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">bw_order_max</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_components</span><span class="p">)</span>
            <span class="n">bw_order</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">([</span><span class="n">bw_order_max</span><span class="p">[</span><span class="n">i</span><span class="p">],(</span><span class="n">bw_order</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_components</span><span class="p">)]</span> <span class="c1">#ensure values are within bounds</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bw_order_min</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bw_order</span><span class="p">)):</span>
            <span class="n">bw_order_min</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">bw_order_min</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N_components</span><span class="p">)</span>
            <span class="n">bw_order</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">([</span><span class="n">bw_order_min</span><span class="p">[</span><span class="n">i</span><span class="p">],(</span><span class="n">bw_order</span><span class="p">[</span><span class="n">i</span><span class="p">])])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N_components</span><span class="p">)]</span> <span class="c1">#ensure values are within bounds</span>
            
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bw_order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>


    <span class="c1">#store in dict:</span>
    <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;peakwl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakwl</span>
    <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;peakwl_min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakwl_min</span>
    <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;peakwl_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakwl_max</span>
    <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fwhm</span>
    <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;fwhm_min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fwhm_min</span>
    <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;fwhm_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fwhm_max</span>
    <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;bw_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bw_order</span>
    <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;bw_order_min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bw_order_min</span>
    <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;bw_order_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bw_order_max</span>
    <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;allow_nongaussianbased_mono_spds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">allow_nongaussianbased_mono_spds</span>
    
    <span class="c1"># Generate random set of pair_strengths (for &#39;2mixer&#39;):</span>
    <span class="k">if</span> <span class="n">pair_strengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;pair_strengths&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">N_components</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;pair_strengths&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pair_strengths</span>

    <span class="c1"># Generate random set of triangle_strengths (for &#39;3mixer&#39;):</span>
    <span class="k">if</span> <span class="n">triangle_strengths</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">combos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">N_components</span><span class="p">),</span> <span class="mi">3</span><span class="p">)))</span> 
        <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">combos</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">opts</span><span class="p">[</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">triangle_strengths</span>

    <span class="k">return</span> <span class="n">opts</span></div>


<div class="viewcode-block" id="initialize_spd_model_pars"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.initialize_spd_model_pars">[docs]</a><span class="k">def</span> <span class="nf">initialize_spd_model_pars</span><span class="p">(</span><span class="n">component_data</span><span class="p">,</span> <span class="n">N_components</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">optimizer_type</span> <span class="o">=</span> <span class="s1">&#39;2mixer&#39;</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize spd_model_pars dict (for spd_constructor) based on type of component_data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :component_data: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Component spectra data: </span>
<span class="sd">            | If int: specifies number of components used in optimization </span>
<span class="sd">            |         (peakwl, fwhm and pair_strengths will be optimized).</span>
<span class="sd">            | If dict: generate components based on parameters (peakwl, fwhm, </span>
<span class="sd">            |          pair_strengths, etc.) in dict. </span>
<span class="sd">            |         (keys with None values will be optimized)</span>
<span class="sd">            | If ndarray: optimize pair_strengths of component spectra.</span>
<span class="sd">        :N_components: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Specifies number of components used in optimization. (only used </span>
<span class="sd">            | when :component_data: is dict and user wants to override dict. </span>
<span class="sd">            | Note that shape of parameters arrays must match N_components).</span>
<span class="sd">        :allow_nongaussianbased_mono_spds:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            |  - False: use Gaussian based monochrom. spds.</span>
<span class="sd">            |  - True: also allow butterworth and lorentzian type monochrom. spds while optimizing.</span>
<span class="sd">        :optimizer_type:</span>
<span class="sd">            | &#39;2mixer&#39;, optional</span>
<span class="sd">            | Type of spectral optimization routine.</span>
<span class="sd">            | (other options: &#39;3mixer&#39;, &#39;search&#39;)</span>
<span class="sd">        :wl: </span>
<span class="sd">            | _WL3, optional</span>
<span class="sd">            | Wavelengths used in optimization when :component_data: is not an</span>
<span class="sd">            | ndarray with spectral data.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :spd_model_pars: </span>
<span class="sd">            | dict with spectrum-model parameters</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">getwlr</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
    <span class="c1"># Initialize parameter dict:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component_data</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>
        <span class="c1"># input is Number of components</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">component_data</span>
        <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="n">get_optim_pars_dict</span><span class="p">(</span><span class="n">N_components</span> <span class="o">=</span> <span class="n">N</span><span class="p">,</span> <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="n">allow_nongaussianbased_mono_spds</span><span class="p">)</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;N_components&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;component_spds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fluxes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;peakwl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;peakwl_min&#39;</span><span class="p">]),</span><span class="nb">max</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;peakwl_max&#39;</span><span class="p">]),</span><span class="n">N</span><span class="p">)</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">wl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">wl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm_min&#39;</span><span class="p">]):</span>
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm_min&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        
        <span class="c1"># Generate list with optimization parameters:    </span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;peakwl&#39;</span><span class="p">,</span><span class="s1">&#39;fwhm&#39;</span><span class="p">]</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">]</span>  
        
        <span class="c1"># Also use butterworth/lorentzian spd profiles, instead of only gaussians:</span>
        <span class="k">if</span> <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;bw_order&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;bw_order&#39;</span><span class="p">)</span>
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;allow_nongaussianbased_mono_spds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">allow_nongaussianbased_mono_spds</span>           
                    
        <span class="c1"># Overwrite with input args:</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;wl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wl</span>
        
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component_data</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="c1"># input is dict with component parameters:</span>
        <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="n">component_data</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="n">N_components</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">N_components</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;N_components&#39;</span><span class="p">]</span>
        
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;N_components&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;component_spds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="k">if</span> <span class="n">component_data</span><span class="p">[</span><span class="s1">&#39;peakwl&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;peakwl&#39;</span><span class="p">)</span>
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
         
        <span class="k">if</span> <span class="n">component_data</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;fwhm&#39;</span><span class="p">)</span>    
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;allow_nongaussianbased_mono_spds&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">component_data</span><span class="p">[</span><span class="s1">&#39;bw_order&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;bw_order&#39;</span><span class="p">)</span>    
                <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
         
        <span class="c1"># Overwrite with input args:</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;wl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">wl</span>
 
    
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># input is ndarray with component spectra</span>
        <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="n">get_optim_pars_dict</span><span class="p">(</span><span class="n">component_spds</span> <span class="o">=</span> <span class="n">component_data</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">component_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;N_components&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">N</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;component_spds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">component_data</span>        
        
        <span class="c1"># store input args:</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;wl&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">component_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
     
    
    <span class="c1"># Append pair ot triangle_strengths to opt_list and opt_len:      </span>
    <span class="k">if</span> <span class="n">optimizer_type</span> <span class="o">==</span> <span class="s1">&#39;2mixer&#39;</span><span class="p">:</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;pair_strengths&#39;</span><span class="p">)</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">optimizer_type</span> <span class="o">==</span><span class="s1">&#39;3mixer&#39;</span><span class="p">:</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;list&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">)</span>
        <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
           
    <span class="k">return</span> <span class="n">spd_model_pars</span></div>

<div class="viewcode-block" id="initialize_spd_optim_pars"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.initialize_spd_optim_pars">[docs]</a><span class="k">def</span> <span class="nf">initialize_spd_optim_pars</span><span class="p">(</span><span class="n">component_data</span><span class="p">,</span> <span class="n">N_components</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                              <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>\
                              <span class="n">optimizer_type</span> <span class="o">=</span> <span class="s1">&#39;2mixer&#39;</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">,</span>\
                              <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize spd_optim_pars dict based on type of component_data.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :component_data: </span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Component spectra data: </span>
<span class="sd">            | If int: specifies number of components used in optimization </span>
<span class="sd">            |         (peakwl, fwhm and pair_strengths will be optimized).</span>
<span class="sd">            | If dict: generate components based on parameters (peakwl, fwhm, </span>
<span class="sd">            |          pair_strengths, etc.) in dict. </span>
<span class="sd">            |         (keys with None values will be optimized)</span>
<span class="sd">            | If ndarray: optimize pair_strengths of component spectra.</span>
<span class="sd">        :N_components:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Specifies number of components used in optimization. (only used </span>
<span class="sd">            | when :component_data: is dict and user wants to override dict. </span>
<span class="sd">            | Note that shape of parameters arrays must match N_components).</span>
<span class="sd">        :allow_nongaussianbased_mono_spds: </span>
<span class="sd">            | False, optional</span>
<span class="sd">            | False: use Gaussian based monochrom. spds.</span>
<span class="sd">        :optimizer_type: </span>
<span class="sd">            | &#39;2mixer&#39;, optional</span>
<span class="sd">            | Type of spectral optimization routine.</span>
<span class="sd">            | (other options: &#39;3mixer&#39;, &#39;search&#39;)</span>
<span class="sd">        :wl:</span>
<span class="sd">            | _WL3, optional</span>
<span class="sd">            | Wavelengths used in optimization when :component_data: is not an</span>
<span class="sd">            | ndarray with spectral data.</span>
<span class="sd">        :spd_model_pars:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | If None, initialize based on type of component_data.</span>
<span class="sd">            | else: initialize on pre-defined spd_model_pars dict.</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        :spd_optim_pars:</span>
<span class="sd">            | dict with optimization parameters (x0, ub, lb)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">getwlr</span><span class="p">(</span><span class="n">wl</span><span class="p">)</span>
    <span class="n">spd_optim_pars</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">spd_model_pars</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="n">initialize_spd_model_pars</span><span class="p">(</span><span class="n">component_data</span><span class="p">,</span> <span class="n">N_components</span> <span class="o">=</span> <span class="n">N_components</span><span class="p">,</span>\
                                               <span class="n">optimizer_type</span> <span class="o">=</span> <span class="n">optimizer_type</span><span class="p">,</span> \
                                               <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="n">allow_nongaussianbased_mono_spds</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">)</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;N_components&#39;</span><span class="p">]</span>

    <span class="c1"># Initialize parameter dict:</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component_data</span><span class="p">,</span><span class="nb">int</span><span class="p">):</span>      
        <span class="c1"># Generate LB, UB, x0 (keys in opt_list):</span>
        <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;peakwl_min&#39;</span><span class="p">],</span> <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm_min&#39;</span><span class="p">]))</span>
        <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;peakwl_max&#39;</span><span class="p">],</span> <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm_max&#39;</span><span class="p">]))</span>
        <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;peakwl&#39;</span><span class="p">],</span> <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">]))</span>
        
        <span class="k">if</span> <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">],</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;bw_order_min&#39;</span><span class="p">]))</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">],</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;bw_order_max&#39;</span><span class="p">]))</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">],</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;bw_order&#39;</span><span class="p">]))</span>

        
        <span class="k">if</span> <span class="n">optimizer_type</span> <span class="o">==</span> <span class="s1">&#39;2mixer&#39;</span><span class="p">:</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">3</span><span class="p">)))</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">3</span><span class="p">)))</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">],</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;pair_strengths&#39;</span><span class="p">]))</span>

        <span class="k">elif</span> <span class="n">optimizer_type</span> <span class="o">==</span> <span class="s1">&#39;3mixer&#39;</span><span class="p">:</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">],</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">]))</span>
        
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component_data</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        
        <span class="c1"># input is dict with component parameters:</span>
        <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">component_data</span><span class="p">[</span><span class="s1">&#39;peakwl&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;peakwl_min&#39;</span><span class="p">])</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;peakwl_max&#39;</span><span class="p">])</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;peakwl_min&#39;</span><span class="p">]),</span><span class="nb">max</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;peakwl_max&#39;</span><span class="p">]),</span><span class="n">N</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">component_data</span><span class="p">[</span><span class="s1">&#39;fwhm&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm_min&#39;</span><span class="p">])</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm_max&#39;</span><span class="p">])</span>
            <span class="n">fwhm_</span> <span class="o">=</span> <span class="p">(</span><span class="n">wl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">wl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fwhm_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">min</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm_min&#39;</span><span class="p">]):</span>
                <span class="n">fwhm_</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm_min&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">fwhm_</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;bw_order_min&#39;</span><span class="p">])</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;bw_order_max&#39;</span><span class="p">])</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;bw_order&#39;</span><span class="p">])</span>

        
        <span class="k">if</span> <span class="n">optimizer_type</span> <span class="o">==</span> <span class="s1">&#39;2mixer&#39;</span><span class="p">:</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">3</span><span class="p">))</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;pair_strengths&#39;</span><span class="p">])</span>
        
        <span class="k">elif</span> <span class="n">optimizer_type</span> <span class="o">==</span> <span class="s1">&#39;3mixer&#39;</span><span class="p">:</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">])</span>
            
        <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">])</span>
        <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">])</span>
        <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">])</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># input is ndarray with component spectra</span>
        <span class="k">if</span> <span class="n">optimizer_type</span> <span class="o">==</span> <span class="s1">&#39;2mixer&#39;</span><span class="p">:</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;pair_strengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">elif</span> <span class="n">optimizer_type</span> <span class="o">==</span><span class="s1">&#39;3mixer&#39;</span><span class="p">:</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;LB&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;UB&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">spd_optim_pars</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span>  <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;triangle_strengths&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">spd_optim_pars</span><span class="p">,</span> <span class="n">spd_model_pars</span></div>

<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="get_primary_fluxratios"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.get_primary_fluxratios">[docs]</a><span class="k">def</span> <span class="nf">get_primary_fluxratios</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">primaries</span><span class="p">,</span> <span class="n">Ytarget</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ptype</span> <span class="o">=</span> <span class="s1">&#39;pu&#39;</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;M,Sopt&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get flux ratios of primaries.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :res:</span>
<span class="sd">            | dict or ndarray with optimized fluxes for component spds normalized to max = 1.</span>
<span class="sd">            | (output of spd_optimizer)</span>
<span class="sd">        :primaries:</span>
<span class="sd">            | ndarray with primary spectra.</span>
<span class="sd">        :Ytarget:</span>
<span class="sd">            | 1, optional</span>
<span class="sd">            | M will be scaled to result in a photo-/radio-metric power of Ytarget</span>
<span class="sd">        :ptype:</span>
<span class="sd">            | &#39;pu&#39; or &#39;ru&#39;, optional</span>
<span class="sd">            | Type of power:</span>
<span class="sd">            | -&#39;pu&#39;: photometric units</span>
<span class="sd">            | -&#39;ru&#39;: radiometric units</span>
<span class="sd">        :cieobs:</span>
<span class="sd">            | _CIEOBS, optional</span>
<span class="sd">            | CMF set/Vlambda to use in calculation of power.</span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :M:</span>
<span class="sd">            | ndarray with flux ratios.</span>
<span class="sd">        :Sopt:</span>
<span class="sd">            | ndarray with optimized scaled spectrum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get maximum of primary spectra:</span>
    <span class="n">max_spds_prim</span> <span class="o">=</span> <span class="n">primaries</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
    
    <span class="c1"># Get M (contribution ratios):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>

    <span class="c1"># Convert M (contribution ratios) to account for the fact that primaries </span>
    <span class="c1"># contains absolute radiant powers, while spd_optimizer function normally </span>
    <span class="c1"># expects normalization to max = 1:</span>
    <span class="n">M</span> <span class="o">/=</span> <span class="n">max_spds_prim</span>
    
    <span class="c1"># Get Sopt spectrum:</span>
    <span class="n">Sopt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">primaries</span><span class="p">[:</span><span class="mi">1</span><span class="p">,:],(</span><span class="n">primaries</span><span class="p">[</span><span class="mi">1</span><span class="p">:,:]</span><span class="o">*</span><span class="n">M</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span>
    
    <span class="c1"># rescale to account for target photometric power:</span>
    <span class="n">Y</span> <span class="o">=</span> <span class="n">spd_to_power</span><span class="p">(</span><span class="n">Sopt</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span><span class="n">ptype</span><span class="o">=</span><span class="n">ptype</span><span class="p">)</span>
    <span class="n">M</span> <span class="o">*=</span> <span class="n">Ytarget</span><span class="o">/</span><span class="n">Y</span>
    
    <span class="c1"># rescale Sopt:</span>
    <span class="n">Sopt</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">*=</span><span class="n">Ytarget</span><span class="o">/</span><span class="n">Y</span>
    
    <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;M,Sopt&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">M</span><span class="p">,</span> <span class="n">Sopt</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;Sopt,M&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Sopt</span><span class="p">,</span> <span class="n">M</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="n">M</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">M</span>
    <span class="k">elif</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;Sopt&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Sopt</span></div>

            
<span class="c1">#------------------------------------------------------------------------------</span>
<div class="viewcode-block" id="spd_optimizer"><a class="viewcode-back" href="../../../../toolboxes.html#luxpy.toolboxes.spdbuild.spd_optimizer">[docs]</a><span class="k">def</span> <span class="nf">spd_optimizer</span><span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="n">np2d</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">3</span><span class="p">]),</span> <span class="n">tar_type</span> <span class="o">=</span> <span class="s1">&#39;Yxy&#39;</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">_CIEOBS</span><span class="p">,</span>\
                  <span class="n">optimizer_type</span> <span class="o">=</span> <span class="s1">&#39;2mixer&#39;</span><span class="p">,</span> <span class="n">spd_constructor</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                  <span class="n">cspace</span> <span class="o">=</span> <span class="s1">&#39;Yuv&#39;</span><span class="p">,</span> <span class="n">cspace_bwtf</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">cspace_fwtf</span> <span class="o">=</span> <span class="p">{},</span>\
                  <span class="n">component_spds</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">N_components</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                  <span class="n">obj_fcn</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="n">obj_fcn_pars</span> <span class="o">=</span> <span class="p">[{}],</span> <span class="n">obj_fcn_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>\
                  <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">decimals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> \
                  <span class="n">minimize_method</span> <span class="o">=</span> <span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">,</span> <span class="n">minimize_opts</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">F_rss</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>\
                  <span class="n">peakwl</span> <span class="o">=</span> <span class="p">[</span><span class="mi">450</span><span class="p">,</span><span class="mi">530</span><span class="p">,</span><span class="mi">610</span><span class="p">],</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">],</span> \
                  <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">bw_order</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>\
                  <span class="n">wl</span> <span class="o">=</span> <span class="n">_WL3</span><span class="p">,</span> <span class="n">with_wl</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">strength_shoulder</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>\
                  <span class="n">strength_ph</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">use_piecewise_fcn</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>\
                  <span class="n">peakwl_ph1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">530</span><span class="p">],</span> <span class="n">fwhm_ph1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">80</span><span class="p">],</span> <span class="n">strength_ph1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span>\
                  <span class="n">peakwl_ph2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">560</span><span class="p">],</span> <span class="n">fwhm_ph2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">80</span><span class="p">],</span> <span class="n">strength_ph2</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                  <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>\
                  <span class="n">pair_strengths</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>\
                  <span class="n">peakwl_min</span> <span class="o">=</span> <span class="p">[</span><span class="mi">400</span><span class="p">],</span> <span class="n">peakwl_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">700</span><span class="p">],</span>\
                  <span class="n">fwhm_min</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">fwhm_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">600</span><span class="p">],</span>\
                  <span class="n">bw_order_min</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="n">bw_order_max</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>\
                  <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;spds,M&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    | Generate a spectrum with specified white point and optimized for certain </span>
<span class="sd">    | objective functions from a set of component spectra or component spectrum </span>
<span class="sd">    | model parameters.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        :target: </span>
<span class="sd">            | np2d([100,1/3,1/3]), optional</span>
<span class="sd">            | ndarray with Yxy chromaticity of target.</span>
<span class="sd">        :tar_type:</span>
<span class="sd">            | &#39;Yxy&#39; or str, optional</span>
<span class="sd">            | Specifies the input type in :target: (e.g. &#39;Yxy&#39; or &#39;cct&#39;)</span>
<span class="sd">        :cieobs:</span>
<span class="sd">            | _CIEOBS, optional</span>
<span class="sd">            | CIE CMF set used to calculate chromaticity values, if not provided </span>
<span class="sd">            | in :Yxyi:.</span>
<span class="sd">        :optimizer_type:</span>
<span class="sd">            | &#39;2mixer&#39;,  optional</span>
<span class="sd">            | Specifies type of chromaticity optimization </span>
<span class="sd">            | (&#39;3mixer&#39; or &#39;2mixer&#39; or &#39;search&#39;)</span>
<span class="sd">            | For help on &#39;2mixer&#39; and &#39;3mixer&#39; algorithms, see notes below.</span>
<span class="sd">        :spd_constructor:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Function handle to user defined spd_constructor function.</span>
<span class="sd">            |     Input: fcn(x, constructor_pars = {}, kwargs)</span>
<span class="sd">            |     Output: spd,M,spds</span>
<span class="sd">            |         nd array with:</span>
<span class="sd">            |             - spd: spectrum resulting from x</span>
<span class="sd">            |             - M: fluxes of all component spds</span>
<span class="sd">            |             - spds: component spds (in [N+1,wl] format)</span>
<span class="sd">            | (See e.g. spd_constructor_2 or spd_constructor_3)</span>
<span class="sd">        :spd_model_pars:</span>
<span class="sd">            | dict with model parameters required by spd_constructor</span>
<span class="sd">            | and with optimization parameters required by minimize (x0, lb, ub).                .</span>
<span class="sd">            | Only used when :optimizer_type: == &#39;user&#39;.</span>
<span class="sd">        :cspace:</span>
<span class="sd">            | &#39;Yuv&#39;, optional</span>
<span class="sd">            | Color space for &#39;search&#39;-type optimization. </span>
<span class="sd">        :cspace_bwtf:</span>
<span class="sd">            | {}, optional</span>
<span class="sd">            | Backward (cspace_to_xyz) transform parameters </span>
<span class="sd">            | (see colortf()) to go from :tar_type: to &#39;Yxy&#39;).</span>
<span class="sd">        :cspace_fwtf:</span>
<span class="sd">            | {}, optional</span>
<span class="sd">            | Forward (xyz_to_cspace) transform parameters </span>
<span class="sd">            | (see colortf()) to go from xyz to :cspace:).</span>
<span class="sd">        :component_spds:</span>
<span class="sd">            | ndarray of component spectra.</span>
<span class="sd">            | If None: they are built from input args.</span>
<span class="sd">        :N_components:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Specifies number of components used in optimization. (only used </span>
<span class="sd">            | when :component_data: is dict and user wants to override dict value</span>
<span class="sd">            | Note that shape of parameters arrays must match N_components).</span>
<span class="sd">        :allow_nongaussianbased_mono_spds:</span>
<span class="sd">            | False, optional</span>
<span class="sd">            | False: use Ohno monochromatic led spectra based on Gaussian spds.</span>
<span class="sd">            | True: also use Butterworth and Lorentzian spds.</span>
<span class="sd">        :wl: </span>
<span class="sd">            | _WL3, optional</span>
<span class="sd">            | Wavelengths used in optimization when :component_data: is not an</span>
<span class="sd">            | ndarray with spectral data.</span>
<span class="sd">        :F_rss: </span>
<span class="sd">            | True, optional</span>
<span class="sd">            | Take Root-Sum-of-Squares of &#39;closeness&#39; values between target and </span>
<span class="sd">            | objective function values.</span>
<span class="sd">        :decimals:</span>
<span class="sd">            | 5, optional</span>
<span class="sd">            | Rounding decimals of objective function values.</span>
<span class="sd">        :obj_fcn: </span>
<span class="sd">            | [None] or list, optional</span>
<span class="sd">            | Function handles to objective function.</span>
<span class="sd">        :obj_fcn_weights:</span>
<span class="sd">            | [1] or list, optional.</span>
<span class="sd">            | Weigths for each obj. fcn</span>
<span class="sd">        :obj_fcn_pars:</span>
<span class="sd">            | [None] or list, optional</span>
<span class="sd">            | Parameter dicts for each obj. fcn.</span>
<span class="sd">        :obj_tar_vals:</span>
<span class="sd">            | [0] or list, optional</span>
<span class="sd">            | Target values for each objective function.</span>
<span class="sd">        :minimize_method:</span>
<span class="sd">            | &#39;Nelder-Mead&#39;, optional</span>
<span class="sd">            | Optimization method used by minimize function.</span>
<span class="sd">        :minimize_opts:</span>
<span class="sd">            | None, optional</span>
<span class="sd">            | Dict with minimization options. </span>
<span class="sd">            |  None defaults to: {&#39;xtol&#39;: 1e-5, &#39;disp&#39;: True, &#39;maxiter&#39;: 1000*Nc,</span>
<span class="sd">            |                     &#39;maxfev&#39; : 1000*Nc,&#39;fatol&#39;: 0.01}</span>
<span class="sd">        :verbosity:</span>
<span class="sd">            | 0, optional</span>
<span class="sd">            | If &gt; 0: print intermediate results.</span>
<span class="sd">        :out:</span>
<span class="sd">            | &#39;spds,M&#39;, optional</span>
<span class="sd">            | Determines output of function.</span>
<span class="sd">         </span>
<span class="sd">    Note:</span>
<span class="sd">        peakwl:, :fwhm:, ... : see ?spd_builder for more info.   </span>
<span class="sd">            </span>
<span class="sd">    Returns:</span>
<span class="sd">        :returns: </span>
<span class="sd">            | spds, M</span>
<span class="sd">            |   - &#39;spds&#39;: optimized spectrum.</span>
<span class="sd">            |   - &#39;M&#39;: ndarray with fluxes for each component spectrum.</span>

<span class="sd">    Notes:</span>
<span class="sd">        :Optimization algorithms:</span>
<span class="sd">            </span>
<span class="sd">        1. &#39;2mixer&#39;:</span>
<span class="sd">        Pairs (odd,even) of components are selected and combined using </span>
<span class="sd">        &#39;pair_strength&#39;. This process is continued until only 3 (combined)</span>
<span class="sd">        intermediate sources remain. Color3mixer is then used to calculate </span>
<span class="sd">        the fluxes for the remaining 3 sources, after which the fluxes of </span>
<span class="sd">        all components are back-calculated.</span>
<span class="sd">            </span>
<span class="sd">        2. &#39;3mixer&#39;:</span>
<span class="sd">        The triangle/trio method creates for all possible combinations of </span>
<span class="sd">        3 primary component spectra a spectrum that results in the target </span>
<span class="sd">        chromaticity using color3mixer() and then optimizes the weights of</span>
<span class="sd">        each of the latter spectra such that adding them (additive mixing) </span>
<span class="sd">        results in obj_vals as close as possible to the target values.</span>

<span class="sd">    &quot;&quot;&quot;</span>
            
    <span class="c1"># Calculate Yxyt (target):</span>
    <span class="n">Yxyt</span> <span class="o">=</span> <span class="n">colortf</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">tf</span> <span class="o">=</span> <span class="n">tar_type</span><span class="o">+</span><span class="s1">&#39;&gt;Yxy&#39;</span><span class="p">,</span> <span class="n">bwtf</span> <span class="o">=</span> <span class="n">cspace_bwtf</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;cieobs&#39;</span> <span class="ow">in</span> <span class="n">cspace_bwtf</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cspace_bwtf</span><span class="p">[</span><span class="s1">&#39;cieobs&#39;</span><span class="p">]</span>
    
    <span class="c1"># Get component spd / data:</span>
    <span class="n">component_spds_original</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">component_spds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">N_components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># Generate component spds from input args:</span>
            <span class="k">if</span> <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">bw_order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">spds</span> <span class="o">=</span> <span class="n">spd_builder</span><span class="p">(</span><span class="n">flux</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">peakwl</span> <span class="o">=</span> <span class="n">peakwl</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhm</span><span class="p">,</span> \
                               <span class="n">bw_order</span> <span class="o">=</span> <span class="n">bw_order</span><span class="p">,</span>\
                               <span class="n">strength_ph</span> <span class="o">=</span> <span class="n">strength_ph</span><span class="p">,</span>\
                               <span class="n">peakwl_ph1</span> <span class="o">=</span> <span class="n">peakwl_ph1</span><span class="p">,</span> <span class="n">fwhm_ph1</span> <span class="o">=</span> <span class="n">fwhm_ph1</span><span class="p">,</span> <span class="n">strength_ph1</span> <span class="o">=</span> <span class="n">strength_ph1</span><span class="p">,</span>\
                               <span class="n">peakwl_ph2</span> <span class="o">=</span> <span class="n">peakwl_ph2</span><span class="p">,</span> <span class="n">fwhm_ph2</span> <span class="o">=</span> <span class="n">fwhm_ph2</span><span class="p">,</span> <span class="n">strength_ph2</span> <span class="o">=</span> <span class="n">strength_ph2</span><span class="p">,</span>\
                               <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">N_components</span> <span class="o">=</span> <span class="n">spds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spds</span> <span class="o">=</span> <span class="n">N_components</span> <span class="c1"># optimize spd model parameters, such as peakwl, fwhm, ... using N components.</span>
            <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="n">initialize_spd_model_pars</span><span class="p">(</span><span class="n">N_components</span><span class="p">,</span> <span class="n">N_components</span> <span class="o">=</span> <span class="n">N_components</span><span class="p">,</span> <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="n">allow_nongaussianbased_mono_spds</span><span class="p">,</span> <span class="n">optimizer_type</span> <span class="o">=</span> <span class="n">optimizer_type</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">)</span>    
            
            <span class="c1"># Update spd_model_pas with values from input arguments:</span>
            <span class="k">def</span> <span class="nf">correct_len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="nb">list</span><span class="p">):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">N_components</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">!=</span> <span class="n">N_components</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Length of list not compatible with N_components=</span><span class="si">{:1.0f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">N_components</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">x</span>
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;peakwl_min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">correct_len</span><span class="p">(</span><span class="n">peakwl_min</span><span class="p">)</span>
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;peakwl_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">correct_len</span><span class="p">(</span><span class="n">peakwl_max</span><span class="p">)</span>
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm_min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">correct_len</span><span class="p">(</span><span class="n">fwhm_min</span><span class="p">)</span>
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;fwhm_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">correct_len</span><span class="p">(</span><span class="n">fwhm_max</span><span class="p">)</span>
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;bw_order_min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">correct_len</span><span class="p">(</span><span class="n">bw_order_min</span><span class="p">)</span>
            <span class="n">spd_model_pars</span><span class="p">[</span><span class="s1">&#39;bw_order_max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">correct_len</span><span class="p">(</span><span class="n">bw_order_max</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">component_spds</span><span class="p">,</span><span class="nb">dict</span><span class="p">):</span> <span class="c1"># optimize spectrum fluxes of set of component spectra defined by parameters in dict</span>
            <span class="k">if</span> <span class="n">N_components</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">N_components</span> <span class="o">=</span> <span class="n">component_spds</span><span class="p">[</span><span class="s1">&#39;N_components&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                
                <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">component_spds</span><span class="p">)</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span> <span class="c1">#isempty</span>
                    <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="n">initialize_spd_model_pars</span><span class="p">(</span><span class="n">N_components</span><span class="p">,</span> <span class="n">N_components</span> <span class="o">=</span> <span class="n">N_components</span><span class="p">,</span> <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="n">allow_nongaussianbased_mono_spds</span><span class="p">,</span> <span class="n">optimizer_type</span> <span class="o">=</span> <span class="n">optimizer_type</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">)</span>
                    <span class="n">spd_model_pars</span><span class="p">[</span><span class="s2">&quot;peakwl&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">peakwl</span>
                    <span class="n">spd_model_pars</span><span class="p">[</span><span class="s2">&quot;fwhm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fwhm</span>
                    
                    <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="n">initialize_spd_model_pars</span><span class="p">(</span><span class="n">spd_model_pars</span><span class="p">,</span> <span class="n">N_components</span> <span class="o">=</span> <span class="n">N_components</span><span class="p">,</span> <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="n">allow_nongaussianbased_mono_spds</span><span class="p">,</span> <span class="n">optimizer_type</span> <span class="o">=</span> <span class="n">optimizer_type</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">)</span>
            <span class="n">spds</span> <span class="o">=</span> <span class="n">spd_model_pars</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># optimize spectrum fluxes of pre-defined set of component spectra:</span>
            <span class="n">spds</span> <span class="o">=</span> <span class="n">component_spds</span> 
            <span class="n">component_spds_original</span> <span class="o">=</span> <span class="n">spds</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># these are the original (unrenormalized) primary spectra.</span>
            <span class="n">N_components</span> <span class="o">=</span> <span class="n">spds</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Check if there are at least 3 spds:</span>
    <span class="k">if</span> <span class="n">N_components</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;spd_optimizer(): At least 3 component spds are required.&#39;</span><span class="p">)</span>

    <span class="c1"># optimize spectrum fluxes, model parameters, ... using optimizer_type method </span>
    <span class="n">spd_opt</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">component_spds</span><span class="p">,</span> <span class="n">obj_vals</span><span class="p">,</span> <span class="n">res</span> <span class="o">=</span> <span class="n">spd_optimizer_2_3</span><span class="p">(</span><span class="n">component_data</span> <span class="o">=</span> <span class="n">spds</span><span class="p">,</span> <span class="n">wl</span> <span class="o">=</span> <span class="n">wl</span><span class="p">,</span>\
                                                    <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="n">allow_nongaussianbased_mono_spds</span><span class="p">,</span> \
                                                    <span class="n">optimizer_type</span> <span class="o">=</span> <span class="n">optimizer_type</span><span class="p">,</span> 
                                                    <span class="n">spd_constructor</span> <span class="o">=</span> <span class="n">spd_constructor</span><span class="p">,</span>\
                                                    <span class="n">spd_model_pars</span> <span class="o">=</span> <span class="n">spd_model_pars</span><span class="p">,</span>\
                                                    <span class="n">Yxy_target</span> <span class="o">=</span> <span class="n">Yxyt</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span>\
                                                    <span class="n">obj_fcn</span> <span class="o">=</span> <span class="n">obj_fcn</span><span class="p">,</span> <span class="n">obj_fcn_pars</span> <span class="o">=</span> <span class="n">obj_fcn_pars</span><span class="p">,</span> <span class="n">obj_fcn_weights</span> <span class="o">=</span> <span class="n">obj_fcn_weights</span><span class="p">,</span>\
                                                    <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="n">obj_tar_vals</span><span class="p">,</span> <span class="n">decimals</span> <span class="o">=</span> <span class="n">decimals</span><span class="p">,</span> \
                                                    <span class="n">minimize_method</span> <span class="o">=</span> <span class="n">minimize_method</span><span class="p">,</span> <span class="n">F_rss</span> <span class="o">=</span> <span class="n">F_rss</span><span class="p">,</span>\
                                                    <span class="n">minimize_opts</span> <span class="o">=</span> <span class="n">minimize_opts</span><span class="p">,</span>\
                                                    <span class="n">verbosity</span> <span class="o">=</span> <span class="n">verbosity</span><span class="p">)</span>
    
    <span class="c1"># Get flux ratios and optimized spectrum:</span>
    <span class="k">if</span> <span class="n">component_spds_original</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">component_spds</span> <span class="o">=</span> <span class="n">component_spds_original</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">M</span><span class="p">,</span> <span class="n">spd_opt</span> <span class="o">=</span> <span class="n">get_primary_fluxratios</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">component_spds</span><span class="p">,</span> <span class="n">Ytarget</span> <span class="o">=</span> <span class="n">Yxyt</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">ptype</span> <span class="o">=</span> <span class="s1">&#39;pu&#39;</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;M,Sopt&#39;</span><span class="p">)</span>
    <span class="n">res</span><span class="p">[</span><span class="s1">&#39;M&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">M</span>
    
    <span class="c1"># get wavelengths</span>
    <span class="n">wl</span> <span class="o">=</span> <span class="n">component_spds</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="c1"># Calculate combined spd from components and their fluxes:</span>
    <span class="n">spds</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">M</span><span class="p">)</span><span class="o">*</span><span class="n">component_spds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">with_wl</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">spds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wl</span><span class="p">,</span> <span class="n">spds</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">out</span> <span class="o">==</span> <span class="s1">&#39;spds,M&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">spds</span><span class="p">,</span> <span class="n">M</span>  
    <span class="k">else</span><span class="p">:</span>  
        <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>
    
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;3: spd_optimizer() with free peakwl and fwhm:&#39;</span><span class="p">)</span>
    <span class="n">cieobs</span><span class="o">=</span><span class="s1">&#39;1931_2&#39;</span>
    <span class="n">cspace_bwtf</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cieobs&#39;</span><span class="p">:</span><span class="n">cieobs</span><span class="p">}</span>
    <span class="n">target</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">4500</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.005</span><span class="p">]])</span> <span class="c1"># specify cct &amp; duv!</span>
    <span class="n">obj_fcn</span> <span class="o">=</span> <span class="p">[</span><span class="n">cri</span><span class="o">.</span><span class="n">spd_to_iesrf</span><span class="p">,</span> <span class="n">cri</span><span class="o">.</span><span class="n">spd_to_iesrg</span><span class="p">]</span>
    <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">85</span><span class="p">,</span><span class="mi">105</span><span class="p">]</span>
    <span class="n">S</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">spd_optimizer</span><span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">,</span> \
                          <span class="n">tar_type</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span>\
                          <span class="n">cspace_bwtf</span> <span class="o">=</span> <span class="n">cspace_bwtf</span><span class="p">,</span>\
                          <span class="n">optimizer_type</span> <span class="o">=</span> <span class="s1">&#39;2mixer&#39;</span><span class="p">,</span>\
                          <span class="n">N_components</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
                          <span class="n">obj_fcn</span> <span class="o">=</span> <span class="n">obj_fcn</span><span class="p">,</span> \
                          <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="n">obj_tar_vals</span><span class="p">,</span>\
                          <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Check output agrees with target:</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">spd_to_xyz</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">relative</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">)</span>
    <span class="n">cct</span> <span class="o">=</span> <span class="n">xyz_to_cct</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="s1">&#39;[cct,duv]&#39;</span><span class="p">)</span>
    <span class="n">Rf</span><span class="p">,</span> <span class="n">Rg</span> <span class="o">=</span> <span class="p">[</span><span class="n">fcn</span><span class="p">(</span><span class="n">S</span><span class="p">)[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">fcn</span> <span class="ow">in</span> <span class="n">obj_fcn</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Results (optim,target):&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cct(K): (</span><span class="si">{:1.1f}</span><span class="s2">,</span><span class="si">{:1.1f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cct</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Duv: (</span><span class="si">{:1.3f}</span><span class="s2">,</span><span class="si">{:1.3f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cct</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">target</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rf: (</span><span class="si">{:1.2f}</span><span class="s2">,</span><span class="si">{:1.2f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Rf</span><span class="p">,</span> <span class="n">obj_tar_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rg: (</span><span class="si">{:1.2f}</span><span class="s2">, </span><span class="si">{:1.2f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Rg</span><span class="p">,</span> <span class="n">obj_tar_vals</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">();</span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">S</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__x&#39;</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;3: spd_optimizer() with constraints on peakwl and fwhm:&#39;</span><span class="p">)</span>
    <span class="n">target</span> <span class="o">=</span> <span class="mi">4500</span>
    <span class="n">cieobs</span><span class="o">=</span><span class="s1">&#39;1931_2&#39;</span>
    <span class="n">obj_fcn</span> <span class="o">=</span> <span class="p">[</span><span class="n">cri</span><span class="o">.</span><span class="n">spd_to_iesrf</span><span class="p">,</span> <span class="n">cri</span><span class="o">.</span><span class="n">spd_to_iesrg</span><span class="p">]</span>
    <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">S4</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">spd_optimizer</span><span class="p">(</span><span class="n">minimize_method</span><span class="o">=</span><span class="s1">&#39;Nelder-Mead&#39;</span><span class="p">,</span>
                          <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">,</span> \
                          <span class="n">tar_type</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span>\
                          <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span>\
                          <span class="n">cspace_bwtf</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cieobs&#39;</span> <span class="p">:</span> <span class="n">cieobs</span><span class="p">},</span>\
                          <span class="n">optimizer_type</span> <span class="o">=</span> <span class="s1">&#39;3mixer&#39;</span><span class="p">,</span>\
                          <span class="n">N_components</span> <span class="o">=</span> <span class="n">n</span><span class="p">,</span>
                          <span class="n">obj_fcn</span> <span class="o">=</span> <span class="n">obj_fcn</span><span class="p">,</span> \
                          <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="n">obj_tar_vals</span><span class="p">,</span>\
                          <span class="n">peakwl_min</span> <span class="o">=</span> <span class="p">[</span><span class="mi">400</span><span class="p">],</span> <span class="n">peakwl_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">700</span><span class="p">],</span>\
                          <span class="n">fwhm_min</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">fwhm_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">300</span><span class="p">],</span>\
                          <span class="n">wl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">360</span><span class="p">,</span><span class="mi">830</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span>\
                          <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># Check output agrees with target:</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">spd_to_xyz</span><span class="p">(</span><span class="n">S4</span><span class="p">,</span> <span class="n">relative</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">)</span>
    <span class="n">cct</span> <span class="o">=</span> <span class="n">xyz_to_cct</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;robertson1968&#39;</span><span class="p">)</span>
    <span class="n">Rf</span> <span class="o">=</span> <span class="n">obj_fcn</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">S4</span><span class="p">)</span>
    <span class="n">Rg</span> <span class="o">=</span> <span class="n">obj_fcn</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">S4</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Results (optim,target):&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cct(K): (</span><span class="si">{:1.1f}</span><span class="s2">,</span><span class="si">{:1.1f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cct</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rf: (</span><span class="si">{:1.2f}</span><span class="s2">,</span><span class="si">{:1.2f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Rf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">obj_tar_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rg: (</span><span class="si">{:1.2f}</span><span class="s2">, </span><span class="si">{:1.2f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Rg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">obj_tar_vals</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="c1">#------------------------------------------------------------------------------</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__x&#39;</span><span class="p">:</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
    <span class="n">cieobs</span> <span class="o">=</span> <span class="s1">&#39;1931_2&#39;</span>
        
    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;1: spd_builder():&#39;</span><span class="p">)</span>
    <span class="c1"># Set up two basis LED spectra:</span>
    <span class="n">target</span> <span class="o">=</span> <span class="mi">3500</span>
    <span class="n">flux</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="c1">#    peakwl = [450,530,590, 595, 600,620,630] # peak wavelengths of monochromatic leds</span>
<span class="c1">#    fwhm = [20,20,20,20,20,20,20] # fwhm of monochromatic leds</span>
<span class="c1">#    </span>
<span class="c1">#    peakwl = [450,530,590, 595] # peak wavelengths of monochromatic leds</span>
<span class="c1">#    fwhm = [20,20,20,20] # fwhm of monochromatic leds</span>

    <span class="n">peakwl</span> <span class="o">=</span><span class="p">[</span><span class="mi">450</span><span class="p">,</span><span class="mi">450</span><span class="p">,</span><span class="mi">450</span><span class="p">]</span>
    <span class="n">fwhm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>

    <span class="n">strength_ph</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span><span class="mf">0.6</span><span class="p">,</span><span class="mf">0.3</span><span class="p">]</span> <span class="c1"># one monochromatic and one phosphor led</span>
    
    <span class="c1"># Parameters for phosphor 1:</span>
    <span class="n">peakwl_ph1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">530</span><span class="p">,</span><span class="mi">550</span><span class="p">,</span><span class="mi">550</span><span class="p">]</span> 
    <span class="n">fwhm_ph1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">80</span><span class="p">,</span><span class="mi">80</span><span class="p">,</span><span class="mi">80</span><span class="p">]</span>
    <span class="n">strength_ph1</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">,</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.8</span><span class="p">]</span>
    
    <span class="c1"># Parameters for phosphor 1:</span>
    <span class="n">peakwl_ph2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">590</span><span class="p">,</span><span class="mi">600</span><span class="p">,</span><span class="mi">600</span><span class="p">]</span>
    <span class="n">fwhm_ph2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">90</span><span class="p">]</span>
    <span class="n">strength_ph2</span> <span class="o">=</span> <span class="kc">None</span> 
    
    <span class="c1"># Build spd from parameters settings defined above:</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">spd_builder</span><span class="p">(</span><span class="n">flux</span> <span class="o">=</span> <span class="n">flux</span><span class="p">,</span> <span class="n">peakwl</span> <span class="o">=</span> <span class="n">peakwl</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhm</span><span class="p">,</span>\
                    <span class="n">strength_ph</span> <span class="o">=</span> <span class="n">strength_ph</span><span class="p">,</span>\
                    <span class="n">peakwl_ph1</span> <span class="o">=</span> <span class="n">peakwl_ph1</span><span class="p">,</span> <span class="n">fwhm_ph1</span> <span class="o">=</span> <span class="n">fwhm_ph1</span><span class="p">,</span> <span class="n">strength_ph1</span> <span class="o">=</span> <span class="n">strength_ph1</span><span class="p">,</span>\
                    <span class="n">peakwl_ph2</span> <span class="o">=</span> <span class="n">peakwl_ph2</span><span class="p">,</span> <span class="n">fwhm_ph2</span> <span class="o">=</span> <span class="n">fwhm_ph2</span><span class="p">,</span> <span class="n">strength_ph2</span> <span class="o">=</span> <span class="n">strength_ph2</span><span class="p">,</span>\
                    <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">,</span> <span class="n">tar_type</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span>\
                    <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1"># Check output agrees with target:</span>
    <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">spd_to_xyz</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">relative</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">)</span>
        <span class="n">cct</span> <span class="o">=</span> <span class="n">xyz_to_cct</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;S: Phosphor model / target cct: </span><span class="si">{:1.1f}</span><span class="s2"> K / </span><span class="si">{:1.1f}</span><span class="s2"> K</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cct</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">))</span>

        
    <span class="c1">#plot final combined spd:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">SPD</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">color</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span><span class="p">)</span>
    
    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="c1"># Set up three basis LED spectra:</span>
    <span class="n">flux</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">peakwl</span> <span class="o">=</span> <span class="p">[</span><span class="mi">450</span><span class="p">,</span><span class="mi">530</span><span class="p">,</span><span class="mi">610</span><span class="p">]</span> <span class="c1"># peak wavelengths of monochromatic leds</span>
    <span class="n">fwhm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">15</span><span class="p">]</span> <span class="c1"># fwhm of monochromatic leds</span>
    
    <span class="n">S2</span> <span class="o">=</span> <span class="n">spd_builder</span><span class="p">(</span><span class="n">flux</span> <span class="o">=</span> <span class="n">flux</span><span class="p">,</span><span class="n">peakwl</span> <span class="o">=</span> <span class="n">peakwl</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhm</span><span class="p">,</span>\
                    <span class="n">strength_ph</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="c1">#plot component spds:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">SPD</span><span class="p">(</span><span class="n">S2</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
 
    
    <span class="c1"># Set peak wavelengths of monochromatic leds:</span>
    <span class="n">peakwl</span> <span class="o">=</span> <span class="p">[</span><span class="mi">450</span><span class="p">,</span><span class="mi">470</span><span class="p">,</span><span class="mi">610</span><span class="p">]</span>
    
    <span class="c1"># Set Full-Width-Half-Maxima of monochromatic leds:</span>
    <span class="n">fwhm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">15</span><span class="p">]</span> 
    
    <span class="n">bw_order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    
    <span class="c1"># Set phosphor strengths:</span>
    <span class="n">strength_ph</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># Set phoshpor 1 parameters:</span>
    <span class="n">strength_ph1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">peakwl_ph1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">530</span><span class="p">,</span> <span class="mi">540</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">fwhm_ph1</span> <span class="o">=</span> <span class="p">[</span><span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">,</span> <span class="mi">60</span><span class="p">]</span>
    
    <span class="c1"># Set phoshpor 2 parameters:</span>
    <span class="n">strength_ph2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">peakwl_ph2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">590</span><span class="p">,</span> <span class="mi">590</span><span class="p">,</span> <span class="mi">590</span><span class="p">]</span>
    <span class="n">fwhm_ph2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">70</span><span class="p">,</span> <span class="mi">70</span><span class="p">,</span> <span class="mi">70</span><span class="p">]</span>
    
    <span class="n">S</span> <span class="o">=</span> <span class="n">spd_builder</span><span class="p">(</span><span class="n">peakwl</span> <span class="o">=</span> <span class="n">peakwl</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhm</span><span class="p">,</span> <span class="n">bw_order</span> <span class="o">=</span> <span class="n">bw_order</span><span class="p">,</span>\
                            <span class="n">strength_ph</span> <span class="o">=</span> <span class="n">strength_ph</span><span class="p">,</span> \
                            <span class="n">strength_ph1</span> <span class="o">=</span> <span class="n">strength_ph1</span><span class="p">,</span>\
                            <span class="n">peakwl_ph1</span> <span class="o">=</span> <span class="n">peakwl_ph1</span><span class="p">,</span>\
                            <span class="n">fwhm_ph1</span> <span class="o">=</span> <span class="n">fwhm_ph1</span><span class="p">,</span>\
                            <span class="n">strength_ph2</span> <span class="o">=</span> <span class="n">strength_ph2</span><span class="p">,</span>\
                            <span class="n">peakwl_ph2</span> <span class="o">=</span> <span class="n">peakwl_ph2</span><span class="p">,</span>\
                            <span class="n">fwhm_ph2</span> <span class="o">=</span> <span class="n">fwhm_ph2</span><span class="p">,</span>\
                           <span class="n">target</span> <span class="o">=</span> <span class="mi">3500</span><span class="p">,</span> <span class="n">tar_type</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span><span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    
    <span class="c1"># Plot component spds:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">SPD</span><span class="p">(</span><span class="n">S</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
    
    <span class="c1"># Check output agrees with target:</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">S</span><span class="p">[(</span><span class="mi">1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">S</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">,:]</span> <span class="c1"># get rid op nan spectra</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">spd_to_xyz</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">relative</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">)</span>
    <span class="n">cct</span> <span class="o">=</span> <span class="n">xyz_to_cct</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">cct</span><span class="p">)</span>
    
    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;2: spd_optimizer():&#39;</span><span class="p">)</span>
    <span class="n">target</span> <span class="o">=</span> <span class="mi">4000</span> <span class="c1"># 4000 K target cct</span>
    <span class="n">tar_type</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span>
    <span class="n">peakwl</span> <span class="o">=</span> <span class="p">[</span><span class="mi">450</span><span class="p">,</span><span class="mi">530</span><span class="p">,</span><span class="mi">560</span><span class="p">,</span><span class="mi">610</span><span class="p">]</span>
    <span class="n">fwhm</span> <span class="o">=</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">15</span><span class="p">]</span> 
    <span class="n">obj_fcn1</span> <span class="o">=</span> <span class="n">cri</span><span class="o">.</span><span class="n">spd_to_iesrf</span>
    <span class="n">obj_fcn2</span> <span class="o">=</span> <span class="n">cri</span><span class="o">.</span><span class="n">spd_to_iesrg</span>
    <span class="n">obj_fcn</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj_fcn1</span><span class="p">,</span> <span class="n">obj_fcn2</span><span class="p">]</span>
    <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
    <span class="n">obj_fcn_weights</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">decimals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
    
    <span class="n">N_components</span> <span class="o">=</span> <span class="mi">4</span> <span class="c1">#if not None, spd model parameters (peakwl, fwhm, ...) are optimized</span>
    <span class="n">component_spds</span> <span class="o">=</span> <span class="kc">None</span><span class="p">;</span> <span class="c1">#component_spds= {}; # if empty dict, then generate using initialize_spd_model_pars and overwrite with function args: peakwl and fwhm. N_components must match length of either peakwl or fwhm</span>
    <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">S3</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">spd_optimizer</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">tar_type</span> <span class="o">=</span> <span class="n">tar_type</span><span class="p">,</span> <span class="n">cspace_bwtf</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cieobs&#39;</span> <span class="p">:</span> <span class="n">cieobs</span><span class="p">},</span>\
                          <span class="n">optimizer_type</span> <span class="o">=</span> <span class="s1">&#39;2mixer&#39;</span><span class="p">,</span> <span class="n">N_components</span> <span class="o">=</span> <span class="n">N_components</span><span class="p">,</span><span class="n">component_spds</span> <span class="o">=</span> <span class="n">component_spds</span><span class="p">,</span>\
                          <span class="n">allow_nongaussianbased_mono_spds</span> <span class="o">=</span> <span class="n">allow_nongaussianbased_mono_spds</span><span class="p">,</span>\
                          <span class="n">peakwl</span> <span class="o">=</span> <span class="n">peakwl</span><span class="p">,</span> <span class="n">fwhm</span> <span class="o">=</span> <span class="n">fwhm</span><span class="p">,</span> <span class="n">obj_fcn</span> <span class="o">=</span> <span class="n">obj_fcn</span><span class="p">,</span> <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="n">obj_tar_vals</span><span class="p">,</span>\
                          <span class="n">obj_fcn_weights</span> <span class="o">=</span> <span class="n">obj_fcn_weights</span><span class="p">,</span> <span class="n">decimals</span> <span class="o">=</span> <span class="n">decimals</span><span class="p">,</span>\
                          <span class="n">use_piecewise_fcn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
                          <span class="c1">#bw_order=[-2],bw_order_min=-2,bw_order_max=-1.5) # to test use of pure lorentzian mono spds.</span>
    
    <span class="c1"># Check output agrees with target:</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">spd_to_xyz</span><span class="p">(</span><span class="n">S3</span><span class="p">,</span> <span class="n">relative</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">)</span>
    <span class="n">cct</span> <span class="o">=</span> <span class="n">xyz_to_cct</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">)</span>
    <span class="n">Rf</span> <span class="o">=</span> <span class="n">obj_fcn1</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
    <span class="n">Rg</span> <span class="o">=</span> <span class="n">obj_fcn2</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">S3: Optimization results:&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;S3: Optim / target cct: </span><span class="si">{:1.1f}</span><span class="s2"> K / </span><span class="si">{:1.1f}</span><span class="s2"> K&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cct</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;S3: Optim / target Rf: </span><span class="si">{:1.3f}</span><span class="s2"> / </span><span class="si">{:1.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Rf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">obj_tar_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;S3: Optim / target Rg: </span><span class="si">{:1.3f}</span><span class="s2"> / </span><span class="si">{:1.3f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Rg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">obj_tar_vals</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    
    <span class="c1">#plot spd:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">SPD</span><span class="p">(</span><span class="n">S3</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="c1">##  </span>
    <span class="c1">#--------------------------------------------------------------------------</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;3: spd_optimizer() with constraints on peakwl and fwhm:&#39;</span><span class="p">)</span>
    <span class="n">target</span> <span class="o">=</span> <span class="mi">5000</span>
    <span class="n">obj_fcn</span> <span class="o">=</span> <span class="p">[</span><span class="n">cri</span><span class="o">.</span><span class="n">spd_to_iesrf</span><span class="p">,</span> <span class="n">cri</span><span class="o">.</span><span class="n">spd_to_iesrg</span><span class="p">]</span>
    <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">90</span><span class="p">,</span><span class="mi">110</span><span class="p">]</span>
    
    <span class="n">S4</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">spd_optimizer</span><span class="p">(</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="p">,</span> \
                          <span class="n">tar_type</span> <span class="o">=</span> <span class="s1">&#39;cct&#39;</span><span class="p">,</span>\
                          <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">,</span>\
                          <span class="n">cspace_bwtf</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;cieobs&#39;</span> <span class="p">:</span> <span class="n">cieobs</span><span class="p">},</span>\
                          <span class="n">optimizer_type</span> <span class="o">=</span> <span class="s1">&#39;3mixer&#39;</span><span class="p">,</span>\
                          <span class="n">N_components</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                          <span class="n">obj_fcn</span> <span class="o">=</span> <span class="n">obj_fcn</span><span class="p">,</span> \
                          <span class="n">obj_tar_vals</span> <span class="o">=</span> <span class="n">obj_tar_vals</span><span class="p">,</span>\
                          <span class="n">peakwl_min</span> <span class="o">=</span> <span class="p">[</span><span class="mi">400</span><span class="p">],</span> <span class="n">peakwl_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">700</span><span class="p">],</span>\
                          <span class="n">fwhm_min</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">fwhm_max</span> <span class="o">=</span> <span class="p">[</span><span class="mi">6</span><span class="p">],</span>\
                          <span class="n">wl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">360</span><span class="p">,</span><span class="mi">830</span><span class="p">,</span><span class="mi">1</span><span class="p">]),</span>\
                          <span class="n">verbosity</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Check output agrees with target:</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">spd_to_xyz</span><span class="p">(</span><span class="n">S4</span><span class="p">,</span> <span class="n">relative</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">)</span>
    <span class="n">cct</span> <span class="o">=</span> <span class="n">xyz_to_cct</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">cieobs</span> <span class="o">=</span> <span class="n">cieobs</span><span class="p">)</span>
    <span class="n">Rf</span> <span class="o">=</span> <span class="n">obj_fcn1</span><span class="p">(</span><span class="n">S4</span><span class="p">)</span>
    <span class="n">Rg</span> <span class="o">=</span> <span class="n">obj_fcn2</span><span class="p">(</span><span class="n">S4</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Results (optim,target):&#39;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;cct(K): (</span><span class="si">{:1.1f}</span><span class="s2">,</span><span class="si">{:1.1f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cct</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">target</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rf: (</span><span class="si">{:1.2f}</span><span class="s2">,</span><span class="si">{:1.2f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Rf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">obj_tar_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Rg: (</span><span class="si">{:1.2f}</span><span class="s2">, </span><span class="si">{:1.2f}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">Rg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">obj_tar_vals</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    
    <span class="c1">#plot spd:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
    <span class="n">SPD</span><span class="p">(</span><span class="n">S4</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Kevin A.G. Smet.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>